<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Contributions 3D Map</title>
    <style>
      /* ... (keep existing styles) ... */
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #0d1117; /* Default, will be overridden by theme */
        color: #c9d1d9;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 20px;
        background: rgba(13, 17, 23, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
      }
      canvas {
        display: block;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      button,
      input {
        background: #21262d;
        border: 1px solid #30363d;
        color: #c9d1d9;
        padding: 6px 12px;
        border-radius: 6px;
        margin: 5px;
        cursor: pointer;
      }
      button:hover {
        background: #30363d;
      }
      label {
        margin-left: 10px;
      }
      /* Style for dat.GUI */
      .dg.main {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 200; /* Ensure it's above other elements */
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading contributions data...</div>
    <div id="info">
      <h2 id="username-display">GitHub Contributions</h2>
      <div id="hover-info">Hover over a cell to see details</div>
      <div id="total-contributions"></div>
    </div>
    <div id="controls">
      <div>
        <label for="username">Username:</label>
        <input type="text" id="username" placeholder="GitHub username" />
        <label for="year">Year:</label>
        <input type="number" id="year" min="2008" max="2025" />
        <button id="load-data">Load Data</button>
      </div>
      <div>
        <button id="reset-camera">Reset Camera</button>
        <input type="checkbox" id="auto-rotate" checked />
        <label for="auto-rotate">Auto Rotate</label>
        <input
          type="range"
          id="height-scale"
          min="0.1"
          max="3"
          step="0.1"
          value="1"
        />
        <label for="height-scale">Height Scale</label>
      </div>
    </div>

    <!-- Include Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Post-processing scripts -->
    <!-- Make sure these paths are correct or use CDN links if available -->
    <!-- Example using local paths (replace with your actual paths or CDNs) -->
    <script src="js/vendor/three/postprocessing/EffectComposer.js"></script>
    <script src="js/vendor/three/postprocessing/RenderPass.js"></script>
    <script src="js/vendor/three/postprocessing/ShaderPass.js"></script>
    <script src="js/vendor/three/shaders/CopyShader.js"></script>
    <script src="js/vendor/three/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/vendor/three/postprocessing/UnrealBloomPass.js"></script>
    <!-- Include dat.GUI and Tween.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
      // Main application
      const app = {
        scene: null,
        camera: null,
        renderer: null,
        minesweeperTextures: null, // Cache for Minesweeper textures
        minesweeperBombMaterial: null, // Material for bomb body
        minesweeperFuseMaterial: null, // Material for bomb fuse
        minesweeperSunkenMaterial: null, // Material for the base under numbers/bombs
        vertexColorMaterial: null, // SHARED material for Standard/Glow base
        controls: null,
        composer: null, // For post-processing
        bloomPass: null, // Reference to the bloom pass
        gui: null, // For dat.GUI controls
        raycaster: new THREE.Raycaster(),
        mouse: new THREE.Vector2(),
        contributionData: null,
        contributionMeshes: [],
        weekLabels: [],
        monthLabels: [],
        config: {
          cellSize: 1,
          cellSpacing: 0.2,
          heightScale: 1,
          autoRotate: true,
          // Standard theme colors (kept for reference/fallback)
          baseColor: 0x0d1117,
          colors: {
            none: 0x161b22,
            first_quartile: 0x0e4429,
            second_quartile: 0x006d32,
            third_quartile: 0x26a641,
            fourth_quartile: 0x39d353,
          },
          highlightColor: 0xffcc00, // Default highlight
        },
        hoveredCell: null,
        username: "torvalds", // Default username
        year: new Date().getFullYear(), // Default year is current year

        // --- Theme Management ---
        currentTheme: "Standard", // Default theme
        themes: {
          Standard: {
            name: "Standard",
            // Standard theme colors moved here
            baseColor: 0x0d1117,
            colors: {
              none: 0x161b22,
              first_quartile: 0x0e4429,
              second_quartile: 0x006d32,
              third_quartile: 0x26a641,
              fourth_quartile: 0x39d353,
            },
            highlightColor: 0xffcc00,
          },
          Glow: {
            name: "Glow",
            baseColor: 0x0d1117,
            colors: {
              // Glow theme might use slightly different base colors
              none: 0x161b22,
              first_quartile: 0x0e4429,
              second_quartile: 0x006d32,
              third_quartile: 0x26a641,
              fourth_quartile: 0x39d353,
            },
            highlightColor: 0xffcc00,
            bloomStrength: 1.0,
            bloomRadius: 0.8,
            bloomThreshold: 0.3,
            toneMappingExposure: 1.5,
            emissiveIntensity: 0.1,
          },
          Minesweeper: {
            name: "Minesweeper",
            baseColor: 0xb0b0b0, // Light gray background
            cellBackgroundColor: "#c0c0c0", // Unclicked tile color (silver/gray) - for empty cells base
            cellBorderColor: "#808080", // Darker border
            cellHighlightColor: 0xffff00, // Yellow highlight on hover
            cellSunkenColor: "#bdbdbd", // Background for revealed numbers/bombs
            numberColors: [
              // Colors for numbers 1-8
              "#0000ff", // 1: Blue
              "#008000", // 2: Green
              "#ff0000", // 3: Red
              "#000080", // 4: Dark Blue
              "#800000", // 5: Maroon
              "#008080", // 6: Teal
              "#000000", // 7: Black
              "#808080", // 8: Gray
            ],
            bombColor: "#1a1a1a", // Dark color for bomb body
            fuseColor: "#555555", // Fuse color
            mineThresholdLevel: 4, // Contributions >= this level are mines
            textureSize: 64, // Size for generated textures
            showHeight: true, // Option to disable height scaling for classic look? (optional)
          },
        },
        themeSettings: {
          // This object will be controlled by dat.GUI
          theme: "Standard",
        },
        minesweeperTextures: null, // Cache for Minesweeper textures
        // --- End Theme Management ---
      };

      // Initialize the application
      function init() {
        setupThreeJS();
        // Initialize the shared vertex color material
        if (!app.vertexColorMaterial) {
          app.vertexColorMaterial = new THREE.MeshLambertMaterial({
            vertexColors: true,
          });
        }
        setupPostProcessing(); // Setup composer and passes
        setupGUI(); // Setup dat.GUI controls
        setupEventListeners();
        setupInitialValues();
        // Apply the initial theme (will generate textures if Minesweeper)
        applyTheme(app.currentTheme, true); // Pass true for initial setup
        animateLoadingText();
        fetchContributionsData();
      }

      // Setup Three.js scene, camera, renderer, lights, controls
      function setupThreeJS() {
        // Create scene
        app.scene = new THREE.Scene();
        // Background color set by applyTheme

        // Create camera
        app.camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        app.camera.position.set(0, 30, 40);
        app.camera.lookAt(0, 0, 0);

        // Create renderer
        app.renderer = new THREE.WebGLRenderer({ antialias: true });
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        app.renderer.shadowMap.enabled = true;
        // Tone mapping will be set by applyTheme
        document.body.appendChild(app.renderer.domElement);

        // Add lights (remains the same)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        app.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 150;
        app.scene.add(directionalLight);

        // OrbitControls (remains the same)
        // Use the embedded OrbitControls code below
        app.controls = new THREE.OrbitControls(
          app.camera,
          app.renderer.domElement
        );
        app.controls.enableDamping = true;
        app.controls.dampingFactor = 0.05;
        app.controls.screenSpacePanning = false;
        app.controls.minDistance = 10;
        app.controls.maxDistance = 100;
        app.controls.maxPolarAngle = Math.PI / 1.8;

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);
      }

      // Setup Post-Processing Effects (Composer and Passes)
      function setupPostProcessing() {
        app.composer = new THREE.EffectComposer(app.renderer);

        const renderPass = new THREE.RenderPass(app.scene, app.camera);
        app.composer.addPass(renderPass);

        // Initialize bloom pass but its parameters will be set by the theme
        app.bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.0, // strength (will be overridden by theme)
          0.5, // radius (will be overridden by theme)
          0.3 // threshold (will be overridden by theme)
        );
        app.composer.addPass(app.bloomPass);

        // Initially disable bloom pass if default theme is not Glow
        app.bloomPass.enabled = app.currentTheme === "Glow";
      }

      // Setup dat.GUI controls
      function setupGUI() {
        app.gui = new dat.GUI();
        app.gui.domElement.classList.add("main"); // Optional: for specific styling

        // Get theme names for the dropdown
        const themeNames = Object.keys(app.themes);

        // Add theme selection controller
        app.gui
          .add(app.themeSettings, "theme", themeNames)
          .name("Theme")
          .onChange((value) => {
            applyTheme(value);
          });
      }

      // Apply a specific theme
      function applyTheme(themeName, isInitialSetup = false) {
        if (!app.themes[themeName]) {
          console.warn(`Theme "${themeName}" not found.`);
          return;
        }

        const oldThemeName = app.currentTheme;
        console.log(`Applying theme: ${themeName}`);
        app.currentTheme = themeName;
        app.themeSettings.theme = themeName; // Sync GUI state

        const themeConfig = app.themes[themeName];
        const isGlow = themeName === "Glow";
        const isMinesweeper = themeName === "Minesweeper";
        const wasMinesweeper = oldThemeName === "Minesweeper";

        // 1. Update Renderer Settings & Background
        app.renderer.toneMapping = isGlow
          ? THREE.ReinhardToneMapping
          : THREE.NoToneMapping;
        app.renderer.toneMappingExposure = isGlow
          ? themeConfig.toneMappingExposure
          : 1.0;

        if (app.scene) {
          app.scene.background = new THREE.Color(themeConfig.baseColor);
          // Update body background for consistency
          document.body.style.backgroundColor = new THREE.Color(
            themeConfig.baseColor
          ).getStyle();
        }

        // 2. Update Post-processing Settings
        if (app.bloomPass) {
          app.bloomPass.enabled = isGlow;
          if (isGlow) {
            app.bloomPass.threshold = themeConfig.bloomThreshold;
            app.bloomPass.strength = themeConfig.bloomStrength;
            app.bloomPass.radius = themeConfig.bloomRadius;
          }
        }

        // 3. Handle Minesweeper Texture Generation (only once needed)
        if (isMinesweeper && !app.minesweeperTextures) {
          console.log("Generating Minesweeper textures...");
          generateMinesweeperTextures(); // Also creates shared materials
        } else if (wasMinesweeper && !isMinesweeper) {
          // Dispose textures AND shared materials if switching AWAY from minesweeper
          disposeMinesweeperTextures();
          disposeBombMaterials(); // Dispose bomb materials too
        }

        // 4. Update Materials of Existing Cells (skip on initial setup before cells exist)
        if (!isInitialSetup) {
          updateAllCellsAppearance();
        }

        // 5. Update Ground Plane Material
        if (app.groundPlane) {
          app.groundPlane.material.color.set(themeConfig.baseColor || 0x10141a);
        }

        // Force GUI update
        if (app.gui) {
          app.gui.__controllers.forEach((controller) => {
            if (controller.property === "theme") {
              controller.updateDisplay();
            }
          });
        }
      }

      // Add disposal for the new shared material
      function disposeSharedMaterials() {
        app.minesweeperSunkenMaterial?.dispose();
        app.minesweeperSunkenMaterial = null;
        app.vertexColorMaterial?.dispose();
        app.vertexColorMaterial = null;
        disposeBombMaterials(); // Dispose bomb materials too
      }

      // --- Minesweeper Texture Generation ---
      function generateMinesweeperTextures() {
        const themeConfig = app.themes.Minesweeper;
        const size = themeConfig.textureSize;
        const textures = {
          numbers: {},
          empty: null,
          sunkenBackground: null, // Just the sunken background for number/bomb tiles
        };

        // Empty Tile Texture (Raised look)
        textures.empty = createMinesweeperBaseTexture(
          size,
          themeConfig.cellBackgroundColor,
          "#ffffff",
          themeConfig.cellBorderColor,
          false
        );

        textures.sunkenBackground = createMinesweeperBaseTexture(
          size,
          themeConfig.cellSunkenColor,
          themeConfig.cellBorderColor,
          "#ffffff",
          true
        ); // Inverted borders for sunken

        // Number Textures (1-8) (Drawn on sunken background canvas)
        for (let i = 1; i <= 8; i++) {
          textures.numbers[i] = createMinesweeperTextTexture(
            i.toString(),
            themeConfig.numberColors[i - 1],
            textures.sunkenBackground, // Pass base texture to draw on
            size
          );
        }

        app.minesweeperTextures = textures;

        // Create the shared sunken material instance
        if (!app.minesweeperSunkenMaterial) {
          const themeConfig = app.themes.Minesweeper; // Get config needed for color
          app.minesweeperSunkenMaterial = new THREE.MeshLambertMaterial({
            color: themeConfig.cellSunkenColor,
          });
        }

        console.log("Minesweeper textures generated:", app.minesweeperTextures);
      }

      // Helper to create the base Minesweeper tile look (raised or sunken)
      // Added 'sunken' flag to invert border colors
      function createMinesweeperBaseTexture(
        size,
        bgColor,
        lightBorder,
        darkBorder,
        sunken = false
      ) {
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");

        // Main background
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, size, size);

        // Border
        const border = Math.max(1, Math.floor(size * 0.03)); // Slightly thinner border
        const topLight = sunken ? darkBorder : lightBorder;
        const bottomDark = sunken ? lightBorder : darkBorder;

        ctx.fillStyle = topLight; // Top-Left Light (or Dark if sunken)
        ctx.fillRect(0, 0, size, border); // Top
        ctx.fillRect(0, 0, border, size); // Left

        ctx.fillStyle = bottomDark; // Bottom-Right Dark (or Light if sunken)
        ctx.fillRect(border, size - border, size - border, border); // Bottom
        ctx.fillRect(size - border, border, border, size - border); // Right

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      }

      // Helper to draw text onto a base texture (passed as argument)
      function createMinesweeperTextTexture(
        text,
        textColor,
        baseTexture,
        size
      ) {
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");

        // Draw the base background texture first
        if (baseTexture && baseTexture.image) {
          ctx.drawImage(baseTexture.image, 0, 0, size, size);
        } else {
          console.warn("Base texture missing for text drawing");
          // Draw fallback background if needed (shouldn't happen ideally)
          ctx.fillStyle = "#bdbdbd";
          ctx.fillRect(0, 0, size, size);
        }

        // Text Styling
        ctx.fillStyle = textColor;
        // Use a fixed pixel size, maybe slightly adjusted by texture size but not scaled *by* it
        const baseFontSize = Math.max(10, size * 0.5); // Adjust base font size as needed
        ctx.font = `bold ${baseFontSize}px "Courier New", Courier, monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // Adjust vertical position slightly if needed
        ctx.fillText(text, size / 2, size / 2 + baseFontSize * 0.05);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      }

      // Helper to draw a bomb icon onto a base texture
      function createMinesweeperBombTexture(size, bombColor, baseTexture) {
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");

        // Draw the base background texture first
        if (baseTexture && baseTexture.image) {
          ctx.drawImage(baseTexture.image, 0, 0, size, size);
        } else {
          console.warn("Base texture missing for bomb");
          ctx.fillStyle = "#bdbdbd"; // Fallback background
          ctx.fillRect(0, 0, size, size);
        }

        // Draw Bomb (simple circle + fuse)
        const bombRadius = size * 0.25;
        const centerX = size / 2;
        const centerY = size / 2;

        ctx.fillStyle = bombColor;
        ctx.beginPath();
        ctx.arc(centerX, centerY, bombRadius, 0, Math.PI * 2);
        ctx.fill();

        // Fuse (simple line)
        ctx.strokeStyle = bombColor;
        ctx.lineWidth = Math.max(1, size * 0.04);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - bombRadius);
        ctx.lineTo(centerX + bombRadius * 0.5, centerY - bombRadius * 1.5);
        // Add a little spark?
        ctx.lineTo(centerX + bombRadius * 0.6, centerY - bombRadius * 1.6);
        ctx.lineTo(centerX + bombRadius * 0.5, centerY - bombRadius * 1.7);
        ctx.lineTo(centerX + bombRadius * 0.4, centerY - bombRadius * 1.6);
        ctx.stroke();

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      }

      // Dispose Minesweeper Textures
      function disposeMinesweeperTextures() {
        if (!app.minesweeperTextures) return;
        console.log("Disposing Minesweeper textures...");

        Object.values(app.minesweeperTextures.numbers).forEach((tex) =>
          tex?.dispose()
        );
        app.minesweeperTextures.empty?.dispose();
        app.minesweeperTextures.sunkenBackground?.dispose(); // Dispose the background too
        app.minesweeperTextures = null;
      }

      // Update materials for all contribution cells based on the current theme
      function updateAllCellMaterials() {
        // console.log("Updating materials for theme:", app.currentTheme);
        app.contributionMeshes.forEach((mesh) => {
          updateSingleCellMaterial(mesh);
        });
      }

      // Call this instead of updateAllCellMaterials
      function updateAllCellsAppearance() {
        app.contributionMeshes.forEach((mesh) => {
          updateCellAppearance(mesh);
        });
      }

      function setupEventListeners() {
        // Mouse move for raycasting
        app.renderer.domElement.addEventListener(
          "mousemove",
          onCanvasMouseMove,
          false
        );

        // Button event listeners
        document.getElementById("load-data").addEventListener("click", () => {
          const usernameInput = document.getElementById("username").value;
          const yearInput = document.getElementById("year").value;

          if (usernameInput) app.username = usernameInput;
          if (yearInput && !isNaN(parseInt(yearInput)))
            app.year = parseInt(yearInput);

          document.getElementById("loading").style.display = "block";
          clearScene();
          fetchContributionsData(); // This will recreate cells with the current theme
        });

        document
          .getElementById("reset-camera")
          .addEventListener("click", () => {
            // Reset camera position with animation
            new TWEEN.Tween(app.camera.position)
              .to({ x: 0, y: 30, z: 40 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
            new TWEEN.Tween(app.controls.target)
              .to({ x: 0, y: 0, z: 0 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .onUpdate(() => app.controls.update())
              .start();
          });

        document
          .getElementById("auto-rotate")
          .addEventListener("change", (e) => {
            app.config.autoRotate = e.target.checked;
            app.controls.autoRotate = app.config.autoRotate;
          });

        document
          .getElementById("height-scale")
          .addEventListener("input", (e) => {
            app.config.heightScale = parseFloat(e.target.value);
            updateHeights(); // Height update is independent of theme material
          });
      }

      function setupInitialValues() {
        document.getElementById("username").value = app.username;
        document.getElementById("year").value = app.year;
        app.controls.autoRotate = app.config.autoRotate;
        document.getElementById("auto-rotate").checked = app.config.autoRotate;
        // Ensure target exists before setting it
        if (app.controls && app.controls.target) {
          app.controls.target.set(0, 0, 0);
          app.controls.update();
        } else {
          console.warn(
            "Controls or target not ready during setupInitialValues"
          );
        }
      }

      function animateLoadingText() {
        // ... (remains the same)
        const loadingEl = document.getElementById("loading");
        let dots = 0;
        if (app.loadingInterval) clearInterval(app.loadingInterval); // Clear previous interval if any
        app.loadingInterval = setInterval(() => {
          dots = (dots + 1) % 4;
          if (document.getElementById("loading").style.display !== "none") {
            loadingEl.textContent = `Loading contributions data${"".padEnd(
              dots,
              "."
            )}`;
          } else {
            clearInterval(app.loadingInterval);
          }
        }, 300);
      }

      function onWindowResize() {
        app.camera.aspect = window.innerWidth / window.innerHeight;
        app.camera.updateProjectionMatrix();
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        // Resize composer and bloom pass as well
        if (app.composer) {
          app.composer.setSize(window.innerWidth, window.innerHeight);
        }
        // if (app.bloomPass) { } // Handled by composer resize
      }

      function onCanvasMouseMove(event) {
        // ... (remains the same)
        const rect = app.renderer.domElement.getBoundingClientRect();
        app.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        app.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      function fetchContributionsData() {
        // ... (remains the same)
        if (app.loadingInterval) clearInterval(app.loadingInterval);
        animateLoadingText();
        generateMockData()
          .then((data) => {
            app.contributionData = data;
            document.getElementById(
              "username-display"
            ).textContent = `${data.username}'s Contributions (${data.years[0]})`;
            document.getElementById(
              "total-contributions"
            ).textContent = `Total: ${data.totalContributions} contributions`;
            createVisualization(); // Will use current theme settings
          })
          .catch((error) => {
            console.error("Failed to load contribution data:", error);
            document.getElementById("loading").textContent =
              "Failed to load data. Check console for details.";
            if (app.loadingInterval) clearInterval(app.loadingInterval);
          });
      }

      function generateMockData() {
        // ... (remains the same - generates data structure)
        return new Promise((resolve) => {
          // Simulate network delay
          setTimeout(() => {
            const days = [];
            const startDate = new Date(app.year, 0, 1);
            const endDate = new Date(app.year, 11, 31);
            let totalContribs = 0;
            let maxContribs = 0; // Find max contributions for level calculation

            // First pass to generate counts and find max
            const tempDays = [];
            for (
              let d = new Date(startDate);
              d <= endDate;
              d.setDate(d.getDate() + 1)
            ) {
              const date = d.toISOString().split("T")[0];
              const dayOfWeek = d.getDay(); // 0 = Sunday, 6 = Saturday
              const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
              const rand = Math.random();
              let count = 0;

              if (!isWeekend || rand > 0.7) {
                const baseProb = isWeekend ? 0.8 : 0.4; // Adjust probability
                if (rand > baseProb) {
                  count = Math.floor(Math.random() * 5) + 1; // Base count
                  if (rand > baseProb + 0.15)
                    count += Math.floor(Math.random() * 8);
                  if (rand > baseProb + 0.3)
                    count += Math.floor(Math.random() * 12);
                  if (rand > baseProb + 0.4)
                    // Make level 4 more likely for Minesweeper testing
                    count += Math.floor(Math.random() * 25); // Increased range
                }
              }
              tempDays.push({ date, count, dayOfWeek });
              totalContribs += count;
              maxContribs = Math.max(maxContribs, count);
            }

            // Define contribution levels based on maxContribs (simplified quartile approach)
            // Ensure thresholds scale reasonably, even with low maxContribs
            const levelThresholds = [
              0, // Level 0 (count == 0)
              1, // Level 1 starts at count 1
              maxContribs > 5 ? Math.ceil(maxContribs * 0.2) : 2, // Level 2 threshold
              maxContribs > 10 ? Math.ceil(maxContribs * 0.45) : 5, // Level 3 threshold
              maxContribs > 15 ? Math.ceil(maxContribs * 0.7) : 10, // Level 4 threshold
            ];

            // Second pass to assign levels and calculate weekOfYear
            tempDays.forEach((tempDay) => {
              const d = new Date(tempDay.date);
              let level = 0;
              let contribLevel = "none";

              // Assign level based on count and thresholds
              if (tempDay.count >= levelThresholds[4]) {
                level = 4;
                contribLevel = "fourth_quartile";
              } else if (tempDay.count >= levelThresholds[3]) {
                level = 3;
                contribLevel = "third_quartile";
              } else if (tempDay.count >= levelThresholds[2]) {
                level = 2;
                contribLevel = "second_quartile";
              } else if (tempDay.count >= levelThresholds[1]) {
                level = 1;
                contribLevel = "first_quartile";
              }

              // Calculate week of year (consistent with GitHub)
              const firstDayOfYear = new Date(d.getFullYear(), 0, 1);
              const pastDaysOfYear = (d - firstDayOfYear) / 86400000;
              // Adjust day offset: Sunday is 0, but GitHub week starts on Sunday.
              // The calculation needs the day of the *first day* of the year.
              let weekStartDayOffset = firstDayOfYear.getDay(); // 0=Sun, 1=Mon..
              const weekOfYear = Math.floor(
                (pastDaysOfYear + weekStartDayOffset) / 7
              );

              days.push({
                date: tempDay.date,
                count: tempDay.count,
                level,
                dayOfWeek: tempDay.dayOfWeek, // 0=Sun, 1=Mon...
                weekOfYear,
                contribLevel,
              });
            });

            resolve({
              username: app.username,
              totalContributions: totalContribs,
              years: [app.year],
              days,
            });
          }, 500);
        });
      }

      function createVisualization() {
        // ... (Grid calculation, ground plane, labels remain the same) ...
        if (!app.contributionData) return;

        const { days } = app.contributionData;
        const cellSize = app.config.cellSize;
        const spacing = app.config.cellSpacing;
        const totalSize = cellSize + spacing;

        const grid = {};
        let maxWeek = 0;

        // Populate grid [week][day] = contribution data
        days.forEach((day) => {
          const weekOfYear = day.weekOfYear;
          // Map dayOfWeek (0=Sun) to grid row index (0..6)
          const dayIndex = day.dayOfWeek; // 0=Sun..6=Sat
          if (weekOfYear >= 0) {
            if (!grid[weekOfYear]) grid[weekOfYear] = Array(7).fill(null); // Initialize week array
            grid[weekOfYear][dayIndex] = day;
            maxWeek = Math.max(maxWeek, weekOfYear);
          } else {
            console.warn("Invalid weekOfYear:", day.date, weekOfYear);
          }
        });

        const numWeeks = maxWeek + 1;
        const gridWidth = numWeeks * totalSize;
        const gridDepth = 7 * totalSize;
        const offsetX = -gridWidth / 2 + totalSize / 2;
        // Adjust Z offset so Sunday (day 0) is at the bottom visually
        const offsetZ = gridDepth / 2 - totalSize / 2;

        // Create ground plane
        const groundGeometry = new THREE.PlaneGeometry(
          gridWidth + 10,
          gridDepth + 10
        );
        const groundMaterial = new THREE.MeshLambertMaterial({
          // Use a color compatible with Minesweeper theme background
          color: app.currentTheme === "Minesweeper" ? 0xa0a0a0 : 0x10141a,
          side: THREE.DoubleSide,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        ground.receiveShadow = true;
        app.scene.add(ground);
        app.groundPlane = ground; // Store reference for potential theme updates

        // Create contribution cells
        for (let week = 0; week <= maxWeek; week++) {
          for (let day = 0; day < 7; day++) {
            // day is 0 (Sun) to 6 (Sat)
            const contribution = grid[week]?.[day];
            const xPos = offsetX + week * totalSize;
            // Calculate zPos where day 0 (Sun) is at the bottom (+Z direction)
            const zPos = offsetZ - day * totalSize;
            // Only create a cell if there's data (even 0 contributions)
            if (contribution !== null) {
              // Check for null, not just falsy
              createContributionCell(
                contribution || {
                  date: `week ${week}, day ${day}`,
                  count: 0,
                  level: 0,
                  contribLevel: "none",
                },
                xPos,
                zPos
              ); // Pass dummy data for empty cells if needed, or only create for actual days
            } else {
              // Optionally create placeholder meshes for days before year start / after year end?
              // For now, leave empty.
            }
          }
        }

        // Add month labels (Adjust Z position based on new layout)
        let lastMonth = -1;
        const monthLabelZ = offsetZ + totalSize * 1.5; // Position above the grid
        days.forEach((day) => {
          if (day.weekOfYear < 0) return; // Skip days with invalid week
          const date = new Date(day.date + "T00:00:00"); // Ensure UTC interpretation
          const month = date.getUTCMonth();
          const week = day.weekOfYear;
          const dayOfMonth = date.getUTCDate();

          // Place label near the start of the month (first week where day <= 7)
          if (month !== lastMonth && dayOfMonth <= 7 && week >= 0) {
            const monthX = offsetX + week * totalSize;
            // Ensure label is created only once per month start
            if (
              app.monthLabels.findIndex(
                (label) => label.userData.month === month
              ) === -1
            ) {
              const label = createMonthLabel(
                date.toLocaleDateString("en-US", { month: "short" }),
                monthX,
                monthLabelZ
              );
              label.userData = { month: month }; // Store month to prevent duplicates
              lastMonth = month;
            }
          }
        });

        // Add day of week labels (Adjust X position based on new layout)
        const dayLabelX = offsetX - totalSize * 1.5; // Position left of the grid
        const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        for (let day = 0; day < 7; day++) {
          // 0=Sun to 6=Sat
          // Adjust logic to match visual layout (e.g., show Mon, Wed, Fri)
          if (day === 1 || day === 3 || day === 5) {
            // Mon, Wed, Fri
            const zPos = offsetZ - day * totalSize; // Z position corresponds to the row
            createDayLabel(daysOfWeek[day], dayLabelX, zPos);
          }
        }

        document.getElementById("loading").style.display = "none";
        if (app.loadingInterval) clearInterval(app.loadingInterval);

        // Center camera (remains the same, assuming center is still 0,0,0)
        const centerTarget = new THREE.Vector3(0, 0, 0);
        new TWEEN.Tween(app.controls.target)
          .to({ x: centerTarget.x, y: centerTarget.y, z: centerTarget.z }, 800)
          .easing(TWEEN.Easing.Cubic.Out)
          .onUpdate(() => app.controls.update())
          .start();
        new TWEEN.Tween(app.camera.position)
          // Adjust camera position slightly based on grid size maybe?
          .to(
            { x: centerTarget.x, y: 35, z: centerTarget.z + gridDepth * 0.8 },
            1000
          )
          .easing(TWEEN.Easing.Cubic.Out)
          .start();
      }

      // Create a single contribution cell
      // Create a single contribution cell (SIMPLIFIED)
      function createContributionCell(contribution, x, z) {
        const cellSize = app.config.cellSize;
        // Base height calculation remains the same
        const isMinesweeper = app.currentTheme === "Minesweeper"; // Check current theme
        const themeConfig = app.themes[app.currentTheme];
        const useHeight = !isMinesweeper || themeConfig.showHeight !== false;
        const baseHeight = isMinesweeper ? 0.05 : 0.1;
        const scaledHeight = useHeight
          ? Math.max(0, contribution.count * 0.1 * app.config.heightScale)
          : 0;
        const totalHeight = baseHeight + scaledHeight;

        const geometry = new THREE.BoxGeometry(cellSize, 1, cellSize);
        geometry.translate(0, 0.5, 0);

        // Create a default base material (will be immediately updated)
        const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); // Placeholder

        const baseMesh = new THREE.Mesh(geometry, baseMaterial);
        baseMesh.position.set(x, 0, z);
        baseMesh.scale.y = totalHeight; // Set initial scale
        baseMesh.castShadow = true;
        baseMesh.receiveShadow = true;
        baseMesh.userData = {
          contribution: contribution,
          originalMaterial: null, // Will be set by updateCellAppearance
          highlightMaterial: new THREE.MeshLambertMaterial({
            // Highlight for base
            color: themeConfig?.highlightColor || app.config.highlightColor, // Use current theme's highlight
          }),
          originalHeight: totalHeight,
          topPlane: null, // Starts null
          bombModel: null, // Starts null
        };
        app.scene.add(baseMesh);
        app.contributionMeshes.push(baseMesh);

        // Set the initial appearance based on the current theme and data RIGHT AFTER creation
        updateCellAppearance(baseMesh); // This will set the correct material and add plane/bomb if needed
      }

      // Update appearance for a single cell (base mesh, top plane, bomb model)
      // NOW handles creation/deletion of plane/bomb
      // Update appearance for a single cell (base mesh, top plane, bomb model)
      function updateCellAppearance(baseMesh) {
        if (!baseMesh || !baseMesh.userData || !baseMesh.userData.contribution)
          return;

        let { contribution, topPlane, bombModel, highlightMaterial } =
          baseMesh.userData;
        const currentThemeName = app.currentTheme;
        const themeConfig = app.themes[currentThemeName];
        const isMinesweeper = currentThemeName === "Minesweeper";
        const isGlow = currentThemeName === "Glow";

        // --- Target Material State ---
        const targetMaterial = isMinesweeper
          ? app.minesweeperSunkenMaterial
          : app.vertexColorMaterial;
        const needsVertexColors = !isMinesweeper;

        // --- Ensure Shared Materials Exist (Safety check) ---
        if (!targetMaterial) {
          console.error(
            `Target material for theme ${currentThemeName} is missing!`
          );
          // Attempt recovery or assign fallback
          if (isMinesweeper && !app.minesweeperSunkenMaterial)
            generateMinesweeperTextures();
          if (!isMinesweeper && !app.vertexColorMaterial) {
            app.vertexColorMaterial = new THREE.MeshLambertMaterial({
              vertexColors: true,
            });
          }
          // Re-assign after potential recovery attempt
          targetMaterial = isMinesweeper
            ? app.minesweeperSunkenMaterial
            : app.vertexColorMaterial;
          if (!targetMaterial) {
            // Still missing? Assign error material.
            console.error(
              "Failed to recover material. Assigning error material."
            );
            if (!baseMesh.material || baseMesh.material === highlightMaterial) {
              baseMesh.material = new THREE.MeshLambertMaterial({
                color: 0xff00ff,
              }); // Use current or create error mat
            } else {
              baseMesh.material.color?.set(0xff00ff); // Try to set color on existing if possible
            }
            return; // Stop processing this cell
          }
        }

        // --- 1. Set Base Mesh Material ---
        // Assign the correct shared material if it's not already set (and not the highlight)
        if (
          baseMesh.material !== targetMaterial &&
          baseMesh.material !== highlightMaterial
        ) {
          console.log(
            `Assigning ${
              isMinesweeper ? "sunken" : "vertex"
            } material to baseMesh`
          );
          // Dispose the OLD material only if it's not one of the shared ones we might reuse
          if (
            baseMesh.material &&
            baseMesh.material !== app.minesweeperSunkenMaterial &&
            baseMesh.material !== app.vertexColorMaterial &&
            baseMesh.material !== highlightMaterial
          ) {
            // Check against highlight too
            baseMesh.material.dispose();
          }
          baseMesh.material = targetMaterial;
          baseMesh.userData.originalMaterial = targetMaterial; // Update original material ref
        }
        // Ensure vertexColors property on the assigned material is correct
        // (This might be redundant if materials are always created correctly, but safe)
        baseMesh.material.vertexColors = needsVertexColors;

        // --- 2. Manage Geometry Vertex Color Attribute ---
        const hasVertexColors = !!baseMesh.geometry.attributes.color;

        if (needsVertexColors && !hasVertexColors) {
          // ADD vertex colors attribute
          console.log(
            `Adding vertex colors attribute for theme ${currentThemeName}`
          );
          const positionAttribute = baseMesh.geometry.attributes.position;
          const colors = [];
          const currentThemeConfig = themeConfig; // Already have themeConfig
          const colorVal = new THREE.Color(
            currentThemeConfig.colors[contribution.contribLevel || "none"]
          );
          const bottomColor =
            contribution.level === 0
              ? colorVal.clone()
              : colorVal.clone().multiplyScalar(0.6);
          for (let i = 0; i < positionAttribute.count; i++) {
            const y = positionAttribute.getY(i);
            const c = y > 0 ? colorVal : bottomColor;
            colors.push(c.r, c.g, c.b);
          }
          baseMesh.geometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
          );
          baseMesh.geometry.attributes.color.needsUpdate = true;
        } else if (!needsVertexColors && hasVertexColors) {
          // REMOVE vertex colors attribute
          console.log(
            `Removing vertex colors attribute for theme ${currentThemeName}`
          );
          baseMesh.geometry.deleteAttribute("color");
        }

        // --- 3. Set Theme-Specific Material Properties (Emissive for Glow) ---
        if (isGlow) {
          const topColor = new THREE.Color(
            themeConfig.colors[contribution.contribLevel || "none"]
          );
          baseMesh.material.emissive.set(topColor); // Use set for colors
          baseMesh.material.emissiveIntensity = themeConfig.emissiveIntensity;
        } else if (baseMesh.material !== highlightMaterial) {
          // Ensure emissive is off for non-glow themes (unless it's the highlight)
          baseMesh.material.emissive?.set(0x000000); // Use set(0x000000)
          baseMesh.material.emissiveIntensity = 0;
        }
        // Flag material for update if we changed emissive props or assigned new material
        if (baseMesh.material !== highlightMaterial) {
          baseMesh.material.needsUpdate = true;
        }

        // --- 4. Manage Minesweeper Child Objects (Plane & Bomb) ---
        if (isMinesweeper) {
          // Ensure Top Plane Exists and is Correct
          if (!topPlane) {
            // Create and configure top plane
            const planeSize = app.config.cellSize * 0.95;
            const topPlaneGeo = new THREE.PlaneGeometry(planeSize, planeSize);
            const topPlaneMat = new THREE.MeshLambertMaterial({
              map: app.minesweeperTextures.empty,
            });
            topPlane = new THREE.Mesh(topPlaneGeo, topPlaneMat);
            topPlane.rotation.x = -Math.PI / 2;
            topPlane.userData.baseMesh = baseMesh;
            app.scene.add(topPlane);
            baseMesh.userData.topPlane = topPlane; // Store reference
          }

          // Update Top Plane Texture and Position
          let texture;
          const count = contribution.count;
          const isMine =
            contribution.level >= themeConfig.mineThresholdLevel && count > 0;

          if (isMine) {
            texture = app.minesweeperTextures.sunkenBackground;
          } else if (count > 0) {
            texture =
              app.minesweeperTextures.numbers[Math.max(1, Math.min(count, 8))];
          } else {
            texture = app.minesweeperTextures.empty;
          }

          if (topPlane.material.map !== texture) {
            topPlane.material.map = texture;
            topPlane.material.needsUpdate = true;
          }
          topPlane.position.set(
            baseMesh.position.x,
            baseMesh.scale.y + 0.01,
            baseMesh.position.z
          );

          // Manage Bomb Model
          if (isMine) {
            if (!bombModel) {
              bombModel = createBombModel(app.config.cellSize);
              app.scene.add(bombModel);
              baseMesh.userData.bombModel = bombModel;
            }
            bombModel.visible = true;
            bombModel.position.set(
              baseMesh.position.x,
              baseMesh.scale.y + 0.01,
              baseMesh.position.z
            );
          } else {
            // Not a mine
            if (bombModel) {
              bombModel.visible = false;
            }
          }
        } else {
          // Not Minesweeper - Clean up child objects
          if (topPlane) {
            if (topPlane.parent) topPlane.parent.remove(topPlane);
            // Dispose geometry/material fully when removing
            topPlane.geometry?.dispose();
            topPlane.material?.map?.dispose();
            topPlane.material?.dispose();
            baseMesh.userData.topPlane = null;
          }
          if (bombModel) {
            bombModel.visible = false; // Hide immediately
            if (bombModel.parent) bombModel.parent.remove(bombModel);
            // Full cleanup of bomb model geometry/materials if needed - handled in clearScene or disposeShared
            baseMesh.userData.bombModel = null; // Remove reference
          }
        }

        // --- 5. Ensure Correct Scale and Child Positions ---
        const useHeight = !isMinesweeper || themeConfig.showHeight !== false;
        const baseHeight = isMinesweeper ? 0.05 : 0.1;
        const scaledHeight = useHeight
          ? Math.max(0, contribution.count * 0.1 * app.config.heightScale)
          : 0;
        const totalHeight = baseHeight + scaledHeight;
        if (Math.abs(baseMesh.scale.y - totalHeight) > 0.001) {
          baseMesh.scale.y = totalHeight;
          const elementYPos = totalHeight + 0.01;
          if (topPlane) topPlane.position.y = elementYPos;
          if (bombModel && bombModel.visible)
            bombModel.position.y = elementYPos;
        }
        // --- Ensure Correct Highlight Color ---
        if (highlightMaterial) {
          const highlightColor = isMinesweeper
            ? themeConfig.cellHighlightColor
            : themeConfig.highlightColor || app.config.highlightColor;
          highlightMaterial.color.set(highlightColor);
        }
      } // End updateCellAppearance

      // Create month/day labels (remain the same)
      function createMonthLabel(text, x, z) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const scaleFactor = 2;
        const baseFontSize = 14;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 64 * scaleFactor;
        canvas.height = 32 * scaleFactor;
        context.fillStyle = "#c9d1d9"; // Standard color, check if needs theme adjustment
        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`;
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.imageSmoothingEnabled = true;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace; // Specify color space
        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
        });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(x, 0.3, z);
        sprite.scale.set(3, 1.5, 1);
        app.scene.add(sprite);
        app.monthLabels.push(sprite);
        return sprite; // Return sprite for potential userData storage
      }

      function createDayLabel(text, x, z) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const scaleFactor = 2;
        const baseFontSize = 12;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 48 * scaleFactor;
        canvas.height = 24 * scaleFactor;
        context.fillStyle = "#c9d1d9"; // Standard color, check if needs theme adjustment
        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`;
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.imageSmoothingEnabled = true;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace; // Specify color space
        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
        });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(x, 0.3, z);
        sprite.scale.set(2.5, 1.25, 1);
        app.scene.add(sprite);
        app.weekLabels.push(sprite);
      }

      // Update heights
      function updateHeights() {
        const isMinesweeper = app.currentTheme === "Minesweeper";
        const themeConfig = app.themes[app.currentTheme];
        const useHeight = !isMinesweeper || themeConfig.showHeight !== false;

        const baseHeight = isMinesweeper ? 0.05 : 0.1;

        app.contributionMeshes.forEach((mesh) => {
          const { contribution, topPlane, bombModel } = mesh.userData;
          const scaledHeight = useHeight
            ? Math.max(0, contribution.count * 0.1 * app.config.heightScale)
            : 0;
          const newTotalHeight = baseHeight + scaledHeight;

          // Update base mesh scale
          mesh.scale.y = newTotalHeight;

          // Update positions of associated elements (if they exist)
          const elementYPos = newTotalHeight + 0.01; // Position slightly above the scaled base
          if (topPlane) {
            topPlane.position.y = elementYPos;
          }
          if (bombModel) {
            bombModel.position.y = elementYPos;
          }
        });
      }

      // Clear scene (Update to dispose materials AND textures)
      function clearScene() {
        // Remove contribution meshes and dispose associated elements
        while (app.contributionMeshes.length > 0) {
          const mesh = app.contributionMeshes.pop();
          const userData = mesh.userData || {};

          // Remove and dispose top plane IF IT EXISTS
          if (userData.topPlane) {
            // Check existence before accessing parent
            if (userData.topPlane.parent)
              userData.topPlane.parent.remove(userData.topPlane);
            userData.topPlane.geometry?.dispose();
            userData.topPlane.material?.map?.dispose();
            userData.topPlane.material?.dispose();
          }

          // Remove bomb model IF IT EXISTS (don't dispose shared materials here)
          if (userData.bombModel) {
            // Check existence before accessing parent
            if (userData.bombModel.parent)
              userData.bombModel.parent.remove(userData.bombModel);
            userData.bombModel.traverse((child) => {
              // Dispose geometry inside
              if (child.isMesh) child.geometry?.dispose();
            });
          }

          // Remove base mesh
          if (mesh.parent) mesh.parent.remove(mesh);
          if (mesh.geometry) mesh.geometry.dispose(); // Dispose unique geometry

          // Dispose the material currently assigned, IF it's not a shared one or highlight
          if (
            mesh.material &&
            mesh.material !== app.minesweeperSunkenMaterial &&
            mesh.material !== app.vertexColorMaterial &&
            mesh.material !== userData.highlightMaterial
          ) {
            // Check highlight too
            mesh.material.dispose();
          }
          // Dispose highlight material (assuming unique per cell)
          if (userData.highlightMaterial) userData.highlightMaterial.dispose();

          mesh.userData = null; // Help GC
        }
        app.contributionMeshes = [];

        // Remove month labels and dispose textures/materials
        while (app.monthLabels.length > 0) {
          const label = app.monthLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          if (label.material) label.material.dispose();
        }
        app.monthLabels = [];

        // Remove day labels and dispose textures/materials
        while (app.weekLabels.length > 0) {
          const label = app.weekLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          if (label.material) label.material.dispose();
        }
        app.weekLabels = [];

        // Remove ground plane
        if (app.groundPlane) {
          if (app.groundPlane.parent)
            app.groundPlane.parent.remove(app.groundPlane);
          if (app.groundPlane.geometry) app.groundPlane.geometry.dispose();
          if (app.groundPlane.material) app.groundPlane.material.dispose();
          app.groundPlane = null;
        }

        // Dispose Minesweeper textures & shared materials (if they exist)
        disposeMinesweeperTextures();
        // Dispose SHARED materials (sunken, vertexColor, bomb)
        disposeSharedMaterials();

        // Reset hover info
        // Reset hover info
        document.getElementById("hover-info").textContent =
          "Hover over a cell to see details";
        app.hoveredCell = null;
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        app.controls.update();
        TWEEN.update();

        // --- Raycasting (Targets baseMesh in app.contributionMeshes) ---
        app.raycaster.setFromCamera(app.mouse, app.camera);
        const intersects = app.raycaster.intersectObjects(
          app.contributionMeshes,
          false
        );

        let intersectedObject = null;
        if (intersects.length > 0) {
          // Find the first intersected object that is a contribution cell base mesh
          for (let i = 0; i < intersects.length; i++) {
            // Check if it's one of our base meshes stored in contributionMeshes
            if (app.contributionMeshes.includes(intersects[i].object)) {
              intersectedObject = intersects[i].object;
              break; // Found the base mesh
            }
          }
        }

        // Handle hover out - Apply to baseMesh
        if (app.hoveredCell && app.hoveredCell !== intersectedObject) {
          if (app.hoveredCell.userData?.originalMaterial) {
            try {
              // Restore the original material of the BASE mesh
              app.hoveredCell.material =
                app.hoveredCell.userData.originalMaterial;
            } catch (e) {
              /* ignore if disposed */
            }
          }
          app.hoveredCell = null;
          document.getElementById("hover-info").textContent =
            "Hover over a cell to see details";
        }

        // Handle hover in - Apply to baseMesh
        if (intersectedObject && app.hoveredCell !== intersectedObject) {
          // Clear previous hover first
          if (app.hoveredCell && app.hoveredCell.userData?.originalMaterial) {
            try {
              app.hoveredCell.material =
                app.hoveredCell.userData.originalMaterial;
            } catch (e) {}
          }

          app.hoveredCell = intersectedObject; // This is the baseMesh
          // Apply highlight material TO THE BASE MESH
          if (app.hoveredCell.userData?.highlightMaterial) {
            // Update highlight material color just in case theme changed
            const currentThemeConfig = app.themes[app.currentTheme];
            const highlightColor =
              app.currentTheme === "Minesweeper"
                ? currentThemeConfig.cellHighlightColor
                : currentThemeConfig.highlightColor ||
                  app.config.highlightColor;
            app.hoveredCell.userData.highlightMaterial.color.set(
              highlightColor
            );

            app.hoveredCell.material =
              app.hoveredCell.userData.highlightMaterial;
          }

          // Update info display
          const { contribution } = app.hoveredCell.userData;
          if (contribution) {
            const date = new Date(contribution.date + "T00:00:00"); // Use UTC date
            const formattedDate = date.toLocaleDateString("en-US", {
              timeZone: "UTC",
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric",
            });
            document.getElementById(
              "hover-info"
            ).innerHTML = `<strong>${formattedDate}</strong><br>${
              contribution.count
            } contribution${contribution.count !== 1 ? "s" : ""}`;
          } else {
            document.getElementById("hover-info").textContent =
              "No data for this cell.";
          }
        }
        // --- End Raycasting ---

        // --- Conditional Rendering ---
        if (
          app.currentTheme === "Glow" &&
          app.composer &&
          app.bloomPass?.enabled
        ) {
          app.composer.render(); // Use composer for Glow theme
        } else {
          app.renderer.render(app.scene, app.camera); // Use direct renderer otherwise
        }
        // --- End Conditional Rendering ---
      }

      // --- Minesweeper Bomb Model ---
      function createBombModel(size) {
          if (!app.minesweeperBombMaterial) {
            app.minesweeperBombMaterial = new THREE.MeshLambertMaterial({
              color: app.themes.Minesweeper.bombColor,
            });
            app.minesweeperFuseMaterial = new THREE.MeshBasicMaterial({
              color: app.themes.Minesweeper.fuseColor,
            }); // Basic material for simple fuse
          }

          const bombGroup = new THREE.Group();

          // Body (Sphere)
          const bodyRadius = size * 0.3;
          const bodyGeometry = new THREE.SphereGeometry(bodyRadius, 16, 8);
          const bodyMesh = new THREE.Mesh(
            bodyGeometry,
            app.minesweeperBombMaterial
          );
          bodyMesh.castShadow = true;
          bombGroup.add(bodyMesh);

          // Fuse (Cylinder or Line)
          const fuseHeight = bodyRadius * 0.6;
          const fuseRadius = bodyRadius * 0.15;
          // Simple Cylinder Fuse
          const fuseGeometry = new THREE.CylinderGeometry(
            fuseRadius,
            fuseRadius,
            fuseHeight,
            8
          );
          const fuseMesh = new THREE.Mesh(
            fuseGeometry,
            app.minesweeperFuseMaterial
          );
          fuseMesh.position.y = bodyRadius + fuseHeight / 2 - fuseHeight * 0.1; // Position on top
          fuseMesh.rotation.z = Math.PI / 8; // Slight tilt
          bombGroup.add(fuseMesh);

          // Optional: Spark (small sphere/sprite?) - Omitted for simplicity

          bombGroup.scale.set(0.8, 0.8, 0.8); // Scale the whole model down slightly if needed
          bombGroup.position.y = 0.02; // Lift slightly off the base plane

          return bombGroup;
        }

        // Dispose bomb materials when clearing scene potentially
        function disposeBombMaterials() {
          app.minesweeperBombMaterial?.dispose();
          app.minesweeperFuseMaterial?.dispose();
          app.minesweeperBombMaterial = null;
          app.minesweeperFuseMaterial = null;
        }
        // --- End Minesweeper Bomb Model ---

      // == OrbitControls Implementation ==
      // [ ... OrbitControls code remains exactly the same ... ]
      // == OrbitControls Implementation ==
      // Using a slightly modified version to ensure compatibility and avoid global conflicts
      THREE.OrbitControls = function (object, domElement) {
        this.object = object;

        this.domElement = domElement !== undefined ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.05;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = false; // if true, pan in screen-space
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = {
          LEFT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.DOLLY,
          RIGHT: THREE.MOUSE.PAN,
        };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {
          return spherical.phi;
        };

        this.getAzimuthalAngle = function () {
          return spherical.theta;
        };

        this.saveState = function () {
          scope.target0.copy(scope.target);
          scope.position0.copy(scope.object.position);
          scope.zoom0 = scope.object.zoom;
        };

        this.reset = function () {
          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;

          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);

          scope.update();

          state = STATE.NONE;
        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = (function () {
          var offset = new THREE.Vector3();

          // so camera.up is the orbit axis
          var quat = new THREE.Quaternion().setFromUnitVectors(
            object.up,
            new THREE.Vector3(0, 1, 0)
          );
          var quatInverse = quat.clone().invert();

          var lastPosition = new THREE.Vector3();
          var lastQuaternion = new THREE.Quaternion();

          return function update() {
            var position = scope.object.position;

            offset.copy(position).sub(scope.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis
            spherical.setFromVector3(offset);

            if (scope.autoRotate && state === STATE.NONE) {
              rotateLeft(getAutoRotationAngle());
            }

            if (scope.enableDamping) {
              spherical.theta += sphericalDelta.theta * scope.dampingFactor;
              spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
              spherical.theta += sphericalDelta.theta;
              spherical.phi += sphericalDelta.phi;
            }

            // restrict theta to be between desired limits
            spherical.theta = Math.max(
              scope.minAzimuthAngle,
              Math.min(scope.maxAzimuthAngle, spherical.theta)
            );

            // restrict phi to be between desired limits
            spherical.phi = Math.max(
              scope.minPolarAngle,
              Math.min(scope.maxPolarAngle, spherical.phi)
            );

            spherical.makeSafe();

            spherical.radius *= scale;

            // restrict radius to be between desired limits
            spherical.radius = Math.max(
              scope.minDistance,
              Math.min(scope.maxDistance, spherical.radius)
            );

            // move target to panned location

            if (scope.enableDamping === true) {
              scope.target.addScaledVector(panOffset, scope.dampingFactor);
            } else {
              scope.target.add(panOffset);
            }

            offset.setFromSpherical(spherical);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(scope.target).add(offset);

            scope.object.lookAt(scope.target);

            if (scope.enableDamping === true) {
              sphericalDelta.theta *= 1 - scope.dampingFactor;
              sphericalDelta.phi *= 1 - scope.dampingFactor;

              panOffset.multiplyScalar(1 - scope.dampingFactor);
            } else {
              sphericalDelta.set(0, 0, 0);

              panOffset.set(0, 0, 0);
            }

            scale = 1;

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (
              zoomChanged ||
              lastPosition.distanceToSquared(scope.object.position) > EPS ||
              8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
            ) {
              scope.dispatchEvent(changeEvent);

              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;

              return true;
            }

            return false;
          };
        })();

        this.dispose = function () {
          scope.domElement.removeEventListener(
            "contextmenu",
            onContextMenu,
            false
          );
          scope.domElement.removeEventListener("mousedown", onMouseDown, false);
          scope.domElement.removeEventListener("wheel", onMouseWheel, false);

          scope.domElement.removeEventListener(
            "touchstart",
            onTouchStart,
            false
          );
          scope.domElement.removeEventListener("touchend", onTouchEnd, false);
          scope.domElement.removeEventListener("touchmove", onTouchMove, false);

          document.removeEventListener("mousemove", onDocumentMouseMove, false); // Use correct name
          document.removeEventListener("mouseup", onDocumentMouseUp, false); // Use correct name

          window.removeEventListener("keydown", onKeyDown, false); // Listen on window

          //scope.dispatchEvent( { type: 'dispose' } ); // should be added to code base according to https://github.com/mrdoob/three.js/pull/1517
        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: "change" };
        var startEvent = { type: "start" };
        var endEvent = { type: "end" };

        var STATE = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_DOLLY_PAN: 4,
        }; // Adjusted states slightly

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();

        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {
          return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
        }

        function getZoomScale() {
          return Math.pow(0.95, scope.zoomSpeed);
        }

        function rotateLeft(angle) {
          sphericalDelta.theta -= angle;
        }

        function rotateUp(angle) {
          sphericalDelta.phi -= angle;
        }

        var panLeft = (function () {
          var v = new THREE.Vector3();

          return function panLeft(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
            v.multiplyScalar(-distance);

            panOffset.add(v);
          };
        })();

        var panUp = (function () {
          var v = new THREE.Vector3();

          return function panUp(distance, objectMatrix) {
            if (scope.screenSpacePanning === true) {
              v.setFromMatrixColumn(objectMatrix, 1);
            } else {
              v.setFromMatrixColumn(objectMatrix, 0);
              v.crossVectors(scope.object.up, v);
            }

            v.multiplyScalar(distance);

            panOffset.add(v);
          };
        })();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = (function () {
          var offset = new THREE.Vector3();

          return function pan(deltaX, deltaY) {
            var element =
              scope.domElement === document
                ? scope.domElement.body
                : scope.domElement;

            if (scope.object.isPerspectiveCamera) {
              // perspective
              var position = scope.object.position;
              offset.copy(position).sub(scope.target);
              var targetDistance = offset.length();

              // half of the fov is center to top of screen
              targetDistance *= Math.tan(
                ((scope.object.fov / 2) * Math.PI) / 180.0
              );

              // we use only clientHeight here so aspect ratio does not distort speed
              panLeft(
                (2 * deltaX * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
              panUp(
                (2 * deltaY * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
            } else if (scope.object.isOrthographicCamera) {
              // orthographic
              panLeft(
                (deltaX * (scope.object.right - scope.object.left)) /
                  scope.object.zoom /
                  element.clientWidth,
                scope.object.matrix
              );
              panUp(
                (deltaY * (scope.object.top - scope.object.bottom)) /
                  scope.object.zoom /
                  element.clientHeight,
                scope.object.matrix
              );
            } else {
              // camera neither orthographic nor perspective
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
              );
              scope.enablePan = false;
            }
          };
        })();

        function dollyIn(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale /= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom * dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        function dollyOut(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale *= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom / dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate(event) {
          rotateStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownDolly(event) {
          dollyStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownPan(event) {
          panStart.set(event.clientX, event.clientY);
        }

        function handleMouseMoveRotate(event) {
          rotateEnd.set(event.clientX, event.clientY);

          rotateDelta
            .subVectors(rotateEnd, rotateStart)
            .multiplyScalar(scope.rotateSpeed);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height

          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleMouseMoveDolly(event) {
          dollyEnd.set(event.clientX, event.clientY);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {
            dollyIn(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyOut(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleMouseMovePan(event) {
          panEnd.set(event.clientX, event.clientY);

          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        // Renamed handler for document mouse up
        function onDocumentMouseUp(/*event*/) {
          if (scope.enabled === false) return;

          document.removeEventListener("mousemove", onDocumentMouseMove, false);
          document.removeEventListener("mouseup", onDocumentMouseUp, false);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        // Renamed handler for document mouse move
        function onDocumentMouseMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          if (state === STATE.ROTATE) {
            if (scope.enableRotate === false) return;
            handleMouseMoveRotate(event);
          } else if (state === STATE.DOLLY) {
            if (scope.enableZoom === false) return;
            handleMouseMoveDolly(event);
          } else if (state === STATE.PAN) {
            if (scope.enablePan === false) return;
            handleMouseMovePan(event);
          }
        }

        function onMouseDown(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          switch (event.button) {
            case scope.mouseButtons.LEFT: // Default: Rotate
              // Modifier check for Pan (Shift/Ctrl/Meta)
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (scope.enablePan === false) return;
                handleMouseDownPan(event);
                state = STATE.PAN;
              } else {
                // No modifier: Rotate
                if (scope.enableRotate === false) return;
                handleMouseDownRotate(event);
                state = STATE.ROTATE;
              }
              break;

            case scope.mouseButtons.MIDDLE: // Default: Dolly
              if (scope.enableZoom === false) return;
              handleMouseDownDolly(event);
              state = STATE.DOLLY;
              break;

            case scope.mouseButtons.RIGHT: // Default: Pan
              if (scope.enablePan === false) return;
              handleMouseDownPan(event);
              state = STATE.PAN;
              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            // Add renamed listeners to document
            document.addEventListener("mousemove", onDocumentMouseMove, false);
            document.addEventListener("mouseup", onDocumentMouseUp, false);

            scope.dispatchEvent(startEvent);
          }
        }

        function onMouseWheel(event) {
          if (
            scope.enabled === false ||
            scope.enableZoom === false ||
            (state !== STATE.NONE && state !== STATE.ROTATE) // Allow zoom while rotating? Maybe not.
          )
            return;

          event.preventDefault();
          event.stopPropagation();

          scope.dispatchEvent(startEvent);
          handleMouseWheel(event);
          scope.dispatchEvent(endEvent);
        }

        function handleMouseWheel(event) {
          // Normalize deltaY value across browsers
          let delta = 0;
          if (event.wheelDelta) {
            // Old WebKit
            delta = -event.wheelDelta / 120;
          } else if (event.deltaY) {
            // Modern standard
            delta = event.deltaY / 3; // Adjust sensitivity?
          }

          if (delta < 0) {
            dollyOut(getZoomScale());
          } else if (delta > 0) {
            dollyIn(getZoomScale());
          }

          scope.update();
        }

        function onKeyDown(event) {
          if (
            scope.enabled === false ||
            scope.enableKeys === false ||
            scope.enablePan === false
          )
            return;

          handleKeyDown(event);
        }

        function handleKeyDown(event) {
          var needsUpdate = false;

          switch (event.keyCode) {
            case scope.keys.UP:
              pan(0, scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.BOTTOM:
              pan(0, -scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.LEFT:
              pan(scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;

            case scope.keys.RIGHT:
              pan(-scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;
          }

          if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            event.preventDefault();
            scope.update();
          }
        }

        function onTouchStart(event) {
          if (scope.enabled === false) return;

          event.preventDefault(); // Prevent scrolling.

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;
              handleTouchStartRotate(event);
              state = STATE.TOUCH_ROTATE;
              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan(event);
              state = STATE.TOUCH_DOLLY_PAN;
              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            scope.dispatchEvent(startEvent);
          }
        }

        function handleTouchStartRotate(event) {
          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchStartDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            panStart.set(x, y);
          }
        }

        function onTouchMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();
          event.stopPropagation();

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;
              if (state !== STATE.TOUCH_ROTATE) return;
              handleTouchMoveRotate(event);
              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              if (state !== STATE.TOUCH_DOLLY_PAN) return;
              handleTouchMoveDollyPan(event);
              break;

            default:
              state = STATE.NONE;
          }
        }

        function handleTouchMoveRotate(event) {
          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
          rotateDelta
            .subVectors(rotateEnd, rotateStart)
            .multiplyScalar(scope.rotateSpeed);
          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;
          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height
          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);
          rotateStart.copy(rotateEnd);
          scope.update();
        }

        function handleTouchMoveDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.set(
              0,
              Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed)
            ); // Calculate dolly delta
            dollyIn(dollyDelta.y); // Apply dolly
            dollyStart.copy(dollyEnd); // Update start point
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            panEnd.set(x, y);
            panDelta
              .subVectors(panEnd, panStart)
              .multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
          }
          scope.update();
        }

        function onTouchEnd(/*event*/) {
          if (scope.enabled === false) return;
          scope.dispatchEvent(endEvent);
          state = STATE.NONE;
        }

        function onContextMenu(event) {
          if (scope.enabled === false) return;
          event.preventDefault();
        }

        // Add event listeners to the domElement
        scope.domElement.addEventListener("contextmenu", onContextMenu, false);
        scope.domElement.addEventListener("mousedown", onMouseDown, false);
        scope.domElement.addEventListener("wheel", onMouseWheel, {
          passive: false,
        }); // Use passive: false if calling preventDefault

        scope.domElement.addEventListener("touchstart", onTouchStart, {
          passive: false,
        }); // Use passive: false
        scope.domElement.addEventListener("touchend", onTouchEnd, false);
        scope.domElement.addEventListener("touchmove", onTouchMove, {
          passive: false,
        }); // Use passive: false

        // Listen to window for keydown event
        window.addEventListener("keydown", onKeyDown, false);

        // force an update at start
        this.update();
      };

      THREE.OrbitControls.prototype = Object.create(
        THREE.EventDispatcher.prototype
      );
      THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

      // Start application
      init();
      animate();
    </script>
  </body>
</html>
