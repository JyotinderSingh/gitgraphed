<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Contributions 3D Map</title>
    <style>
      /* ... (keep existing styles) ... */
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #0d1117; /* Default, will be overridden by theme */
        color: #c9d1d9;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 20px;
        background: rgba(13, 17, 23, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
      }
      canvas {
        display: block;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      button,
      input {
        background: #21262d;
        border: 1px solid #30363d;
        color: #c9d1d9;
        padding: 6px 12px;
        border-radius: 6px;
        margin: 5px;
        cursor: pointer;
      }
      button:hover {
        background: #30363d;
      }
      label {
        margin-left: 10px;
      }
      /* Style for dat.GUI */
      .dg.main {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 200; /* Ensure it's above other elements */
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading contributions data...</div>
    <div id="info">
      <h2 id="username-display">GitHub Contributions</h2>
      <div id="hover-info">Hover over a cell to see details</div>
      <div id="total-contributions"></div>
    </div>
    <div id="controls">
      <div>
        <label for="username">Username:</label>
        <input type="text" id="username" placeholder="GitHub username" />
        <label for="year">Year:</label>
        <input type="number" id="year" min="2008" max="2025" />
        <button id="load-data">Load Data</button>
      </div>
      <div>
        <button id="reset-camera">Reset Camera</button>
        <input type="checkbox" id="auto-rotate" checked />
        <label for="auto-rotate">Auto Rotate</label>
        <input
          type="range"
          id="height-scale"
          min="0.1"
          max="3"
          step="0.1"
          value="1"
        />
        <label for="height-scale">Height Scale</label>
      </div>
    </div>

    <!-- Include Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Post-processing scripts -->
    <!-- Make sure these paths are correct or use CDN links if available -->
    <!-- Example using local paths (replace with your actual paths or CDNs) -->
    <script src="js/vendor/three/postprocessing/EffectComposer.js"></script>
    <script src="js/vendor/three/postprocessing/RenderPass.js"></script>
    <script src="js/vendor/three/postprocessing/ShaderPass.js"></script>
    <script src="js/vendor/three/shaders/CopyShader.js"></script>
    <script src="js/vendor/three/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/vendor/three/postprocessing/UnrealBloomPass.js"></script>
    <!-- Include dat.GUI and Tween.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
      // Main application
      const app = {
        scene: null,
        camera: null,
        renderer: null,
        controls: null,
        composer: null, // For post-processing
        bloomPass: null, // Reference to the bloom pass
        gui: null, // For dat.GUI controls
        raycaster: new THREE.Raycaster(),
        mouse: new THREE.Vector2(),
        contributionData: null,
        contributionMeshes: [],
        weekLabels: [],
        monthLabels: [],
        config: {
          cellSize: 1,
          cellSpacing: 0.2,
          heightScale: 1,
          autoRotate: true,
          // Standard theme colors (kept for reference/fallback)
          baseColor: 0x0d1117,
           colors: {
              none: 0x161b22,
              first_quartile: 0x0e4429,
              second_quartile: 0x006d32,
              third_quartile: 0x26a641,
              fourth_quartile: 0x39d353,
          },
          highlightColor: 0xffcc00, // Default highlight
        },
        hoveredCell: null,
        username: "torvalds", // Default username
        year: new Date().getFullYear(), // Default year is current year

        // --- Theme Management ---
        currentTheme: "Standard", // Default theme
        themes: {
          Standard: {
            name: "Standard",
             // Standard theme colors moved here
            baseColor: 0x0d1117,
            colors: {
              none: 0x161b22,
              first_quartile: 0x0e4429,
              second_quartile: 0x006d32,
              third_quartile: 0x26a641,
              fourth_quartile: 0x39d353,
            },
            highlightColor: 0xffcc00,
          },
          Glow: {
            name: "Glow",
            baseColor: 0x0d1117,
            colors: { // Glow theme might use slightly different base colors
              none: 0x161b22,
              first_quartile: 0x0e4429,
              second_quartile: 0x006d32,
              third_quartile: 0x26a641,
              fourth_quartile: 0x39d353,
            },
            highlightColor: 0xffcc00,
            bloomStrength: 1.0,
            bloomRadius: 0.8,
            bloomThreshold: 0.3,
            toneMappingExposure: 1.5,
            emissiveIntensity: 0.1,
          },
          Minesweeper: {
              name: "Minesweeper",
              baseColor: 0xb0b0b0, // Light gray background like classic Minesweeper
              cellBackgroundColor: '#c0c0c0', // Unclicked tile color (silver/gray)
              cellBorderColor: '#808080', // Darker border
              cellHighlightColor: 0xffff00, // Yellow highlight on hover
              numberColors: [ // Colors for numbers 1-8
                  '#0000ff', // 1: Blue
                  '#008000', // 2: Green
                  '#ff0000', // 3: Red
                  '#000080', // 4: Dark Blue
                  '#800000', // 5: Maroon
                  '#008080', // 6: Teal
                  '#000000', // 7: Black
                  '#808080'  // 8: Gray
              ],
              bombColor: '#000000', // Bomb icon color
              mineThresholdLevel: 4, // Use Level 4 contributions as "mines"
              textureSize: 64, // Size for generated textures
          }
        },
        themeSettings: {
          // This object will be controlled by dat.GUI
          theme: "Standard",
        },
        minesweeperTextures: null, // Cache for Minesweeper textures
        // --- End Theme Management ---
      };

      // Initialize the application
      function init() {
        setupThreeJS();
        setupPostProcessing(); // Setup composer and passes
        setupGUI(); // Setup dat.GUI controls
        setupEventListeners();
        setupInitialValues();
        // Apply the initial theme (will generate textures if Minesweeper)
        applyTheme(app.currentTheme, true); // Pass true for initial setup
        animateLoadingText();
        fetchContributionsData();
      }

      // Setup Three.js scene, camera, renderer, lights, controls
      function setupThreeJS() {
        // Create scene
        app.scene = new THREE.Scene();
        // Background color set by applyTheme

        // Create camera
        app.camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        app.camera.position.set(0, 30, 40);
        app.camera.lookAt(0, 0, 0);

        // Create renderer
        app.renderer = new THREE.WebGLRenderer({ antialias: true });
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        app.renderer.shadowMap.enabled = true;
        // Tone mapping will be set by applyTheme
        document.body.appendChild(app.renderer.domElement);

        // Add lights (remains the same)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        app.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 150;
        app.scene.add(directionalLight);

        // OrbitControls (remains the same)
        // Use the embedded OrbitControls code below
        app.controls = new THREE.OrbitControls(
          app.camera,
          app.renderer.domElement
        );
        app.controls.enableDamping = true;
        app.controls.dampingFactor = 0.05;
        app.controls.screenSpacePanning = false;
        app.controls.minDistance = 10;
        app.controls.maxDistance = 100;
        app.controls.maxPolarAngle = Math.PI / 1.8;

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);
      }

      // Setup Post-Processing Effects (Composer and Passes)
      function setupPostProcessing() {
        app.composer = new THREE.EffectComposer(app.renderer);

        const renderPass = new THREE.RenderPass(app.scene, app.camera);
        app.composer.addPass(renderPass);

        // Initialize bloom pass but its parameters will be set by the theme
        app.bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.0, // strength (will be overridden by theme)
          0.5, // radius (will be overridden by theme)
          0.3 // threshold (will be overridden by theme)
        );
        app.composer.addPass(app.bloomPass);

        // Initially disable bloom pass if default theme is not Glow
        app.bloomPass.enabled = app.currentTheme === "Glow";
      }

       // Setup dat.GUI controls
       function setupGUI() {
        app.gui = new dat.GUI();
        app.gui.domElement.classList.add('main'); // Optional: for specific styling

        // Get theme names for the dropdown
        const themeNames = Object.keys(app.themes);

        // Add theme selection controller
        app.gui.add(app.themeSettings, 'theme', themeNames)
          .name('Theme')
          .onChange((value) => {
            applyTheme(value);
          });
      }

      // Apply a specific theme
      function applyTheme(themeName, isInitialSetup = false) {
        if (!app.themes[themeName]) {
          console.warn(`Theme "${themeName}" not found.`);
          return;
        }

        console.log(`Applying theme: ${themeName}`);
        app.currentTheme = themeName;
        app.themeSettings.theme = themeName; // Sync GUI state

        const themeConfig = app.themes[themeName];
        const isGlow = themeName === "Glow";
        const isMinesweeper = themeName === "Minesweeper";

        // 1. Update Renderer Settings & Background
        app.renderer.toneMapping = isGlow
          ? THREE.ReinhardToneMapping
          : THREE.NoToneMapping;
        app.renderer.toneMappingExposure = isGlow
          ? themeConfig.toneMappingExposure
          : 1.0;

        if (app.scene) {
            app.scene.background = new THREE.Color(themeConfig.baseColor);
            // Update body background for consistency
            document.body.style.backgroundColor = new THREE.Color(themeConfig.baseColor).getStyle();
        }

        // 2. Update Post-processing Settings
        if (app.bloomPass) {
          app.bloomPass.enabled = isGlow;
          if (isGlow) {
            app.bloomPass.threshold = themeConfig.bloomThreshold;
            app.bloomPass.strength = themeConfig.bloomStrength;
            app.bloomPass.radius = themeConfig.bloomRadius;
          }
        }

        // 3. Handle Minesweeper Texture Generation (only once needed)
        if (isMinesweeper && !app.minesweeperTextures) {
            console.log("Generating Minesweeper textures...");
            generateMinesweeperTextures();
        }

        // 4. Update Materials of Existing Cells (skip on initial setup before cells exist)
        if (!isInitialSetup) {
            updateAllCellMaterials();
        }

        // Force GUI update
        if (app.gui) {
            app.gui.__controllers.forEach(controller => {
                if (controller.property === 'theme') {
                    controller.updateDisplay();
                }
            });
        }
      }

      // --- Minesweeper Texture Generation ---
      function generateMinesweeperTextures() {
          const themeConfig = app.themes.Minesweeper;
          const size = themeConfig.textureSize;
          const textures = {
              numbers: {},
              bomb: null,
              empty: null,
              mineBackground: null, // Background for the bomb tile
          };

          // Empty Tile Texture (Raised look)
          textures.empty = createMinesweeperBaseTexture(size, themeConfig.cellBackgroundColor, '#ffffff', themeConfig.cellBorderColor);

          // Number Textures (1-8) (Sunken look)
          const numberBgColor = '#bdbdbd'; // Slightly darker for numbers
          for (let i = 1; i <= 8; i++) {
              textures.numbers[i] = createMinesweeperTextTexture(
                  i.toString(),
                  themeConfig.numberColors[i - 1],
                  numberBgColor, // Sunken background
                  size,
                  themeConfig.cellBorderColor, // Sunken border dark
                  '#ffffff' // Sunken border light
              );
          }

          // Bomb Texture (Sunken look)
          textures.mineBackground = createMinesweeperBaseTexture(size, numberBgColor, themeConfig.cellBorderColor, '#ffffff'); // Use sunken background
          textures.bomb = createMinesweeperBombTexture(size, themeConfig.bombColor, textures.mineBackground); // Draw bomb on sunken bg

          app.minesweeperTextures = textures;
          console.log("Minesweeper textures generated:", app.minesweeperTextures);
      }

        // Helper to create the base Minesweeper tile look (raised or sunken)
        function createMinesweeperBaseTexture(size, bgColor, lightBorder, darkBorder) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Main background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, size, size);

            // Border
            const border = Math.max(1, Math.floor(size * 0.05)); // Border width
            ctx.fillStyle = lightBorder;
            ctx.fillRect(0, 0, size, border); // Top
            ctx.fillRect(0, 0, border, size); // Left
            ctx.fillStyle = darkBorder;
            ctx.fillRect(0, size - border, size, border); // Bottom
            ctx.fillRect(size - border, 0, border, size); // Right

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace; // Important for color accuracy
            return texture;
        }

        // Helper to draw text onto a base texture
        function createMinesweeperTextTexture(text, textColor, bgColor, size, darkBorder, lightBorder) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

             // Background and Border (sunken appearance)
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, size, size);
            const border = Math.max(1, Math.floor(size * 0.05));
            ctx.fillStyle = darkBorder; // Dark top/left for sunken
            ctx.fillRect(0, 0, size, border);
            ctx.fillRect(0, 0, border, size);
            ctx.fillStyle = lightBorder; // Light bottom/right for sunken
            ctx.fillRect(0, size - border, size, border);
            ctx.fillRect(size - border, 0, border, size);


            // Text Styling
            ctx.fillStyle = textColor;
            ctx.font = `bold ${size * 0.6}px "Courier New", Courier, monospace`; // Classic fixed-width font
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size / 2, size / 2 + size * 0.05); // Slight vertical offset

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Helper to draw a bomb icon onto a base texture
        function createMinesweeperBombTexture(size, bombColor, baseTexture) {
             const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Draw the base background texture first
             if (baseTexture && baseTexture.image) {
                 ctx.drawImage(baseTexture.image, 0, 0, size, size);
            } else {
                 console.warn("Base texture missing for bomb");
                 ctx.fillStyle = '#bdbdbd'; // Fallback background
                 ctx.fillRect(0, 0, size, size);
            }


            // Draw Bomb (simple circle + fuse)
            const bombRadius = size * 0.25;
            const centerX = size / 2;
            const centerY = size / 2;

            ctx.fillStyle = bombColor;
            ctx.beginPath();
            ctx.arc(centerX, centerY, bombRadius, 0, Math.PI * 2);
            ctx.fill();

            // Fuse (simple line)
            ctx.strokeStyle = bombColor;
            ctx.lineWidth = Math.max(1, size * 0.04);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - bombRadius);
            ctx.lineTo(centerX + bombRadius * 0.5, centerY - bombRadius * 1.5);
             // Add a little spark?
            ctx.lineTo(centerX + bombRadius * 0.6, centerY - bombRadius * 1.6);
             ctx.lineTo(centerX + bombRadius * 0.5, centerY - bombRadius * 1.7);
             ctx.lineTo(centerX + bombRadius * 0.4, centerY - bombRadius * 1.6);
            ctx.stroke();


            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Dispose Minesweeper Textures
        function disposeMinesweeperTextures() {
            if (!app.minesweeperTextures) return;
            console.log("Disposing Minesweeper textures...");

            Object.values(app.minesweeperTextures.numbers).forEach(tex => tex?.dispose());
            app.minesweeperTextures.bomb?.dispose();
            app.minesweeperTextures.empty?.dispose();
            app.minesweeperTextures.mineBackground?.dispose(); // Dispose the background too
            app.minesweeperTextures = null;
        }

      // Update materials for all contribution cells based on the current theme
      function updateAllCellMaterials() {
        // console.log("Updating materials for theme:", app.currentTheme);
        app.contributionMeshes.forEach(mesh => {
          updateSingleCellMaterial(mesh);
        });
      }

      // Update material for a single cell
      function updateSingleCellMaterial(mesh) {
        if (!mesh || !mesh.userData || !mesh.userData.contribution) return;

        const { contribution } = mesh.userData;
        const currentThemeName = app.currentTheme;
        const themeConfig = app.themes[currentThemeName];

        // Dispose previous material(s) to prevent memory leaks
        if (mesh.material) mesh.material.dispose();
        if (mesh.userData.originalMaterial && mesh.userData.originalMaterial !== mesh.material) {
            mesh.userData.originalMaterial.dispose();
        }
        // Make sure highlight material is also themed if needed, or kept separate
        // For now, we will reuse the highlightMaterial instance but update its color potentially


        let newMaterial;

        if (currentThemeName === 'Minesweeper') {
            if (!app.minesweeperTextures) {
                console.error("Minesweeper textures not generated!");
                // Fallback material
                newMaterial = new THREE.MeshLambertMaterial({ color: 0xff00ff });
            } else {
                let texture;
                const count = contribution.count;
                const level = contribution.level; // Level determined by mock data ranges

                if (level >= themeConfig.mineThresholdLevel && count > 0) {
                    texture = app.minesweeperTextures.bomb;
                } else if (count > 0) {
                    // Clamp count to 1-8 for texture index
                    const numIndex = Math.max(1, Math.min(count, 8));
                    texture = app.minesweeperTextures.numbers[numIndex];
                } else {
                    texture = app.minesweeperTextures.empty;
                }

                 if (!texture) { // Safety check if a texture failed generation
                     console.warn("Missing texture for count/level", count, level, "Using empty.");
                     texture = app.minesweeperTextures.empty;
                 }

                newMaterial = new THREE.MeshLambertMaterial({
                    map: texture,
                    // color: 0xffffff, // Set color to white to avoid tinting the texture
                });
            }
             // Update highlight color for Minesweeper
            if (mesh.userData.highlightMaterial) {
                 mesh.userData.highlightMaterial.color.set(themeConfig.cellHighlightColor || 0xffff00); // Use theme's highlight or yellow fallback
            }


        } else { // Standard or Glow themes
            const isGlow = currentThemeName === "Glow";
            const topColor = new THREE.Color(themeConfig.colors[contribution.contribLevel]);

            newMaterial = new THREE.MeshLambertMaterial({
              vertexColors: true, // Use vertex colors for gradient
              emissive: isGlow ? topColor : 0x000000,
              emissiveIntensity: isGlow ? themeConfig.emissiveIntensity : 0,
            });

             // Reset highlight color for non-Minesweeper themes
            if (mesh.userData.highlightMaterial) {
                 mesh.userData.highlightMaterial.color.set(themeConfig.highlightColor || 0xffcc00);
            }
        }

        mesh.material = newMaterial;
        mesh.userData.originalMaterial = newMaterial; // Store reference for hover reset
      }

      function setupEventListeners() {
        // Mouse move for raycasting
        app.renderer.domElement.addEventListener(
          "mousemove",
          onCanvasMouseMove,
          false
        );

        // Button event listeners
        document.getElementById("load-data").addEventListener("click", () => {
          const usernameInput = document.getElementById("username").value;
          const yearInput = document.getElementById("year").value;

          if (usernameInput) app.username = usernameInput;
          if (yearInput && !isNaN(parseInt(yearInput))) app.year = parseInt(yearInput);

          document.getElementById("loading").style.display = "block";
          clearScene();
          fetchContributionsData(); // This will recreate cells with the current theme
        });

        document
          .getElementById("reset-camera")
          .addEventListener("click", () => {
             // Reset camera position with animation
            new TWEEN.Tween(app.camera.position)
              .to({ x: 0, y: 30, z: 40 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
            new TWEEN.Tween(app.controls.target)
              .to({ x: 0, y: 0, z: 0 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .onUpdate(() => app.controls.update())
              .start();
          });

        document
          .getElementById("auto-rotate")
          .addEventListener("change", (e) => {
            app.config.autoRotate = e.target.checked;
            app.controls.autoRotate = app.config.autoRotate;
          });

        document
          .getElementById("height-scale")
          .addEventListener("input", (e) => {
            app.config.heightScale = parseFloat(e.target.value);
            updateHeights(); // Height update is independent of theme material
          });
      }

      function setupInitialValues() {
        document.getElementById("username").value = app.username;
        document.getElementById("year").value = app.year;
        app.controls.autoRotate = app.config.autoRotate;
        document.getElementById("auto-rotate").checked = app.config.autoRotate;
        // Ensure target exists before setting it
        if (app.controls && app.controls.target) {
             app.controls.target.set(0, 0, 0);
             app.controls.update();
        } else {
             console.warn("Controls or target not ready during setupInitialValues");
        }

      }

      function animateLoadingText() {
        // ... (remains the same)
         const loadingEl = document.getElementById("loading");
        let dots = 0;
        if (app.loadingInterval) clearInterval(app.loadingInterval); // Clear previous interval if any
        app.loadingInterval = setInterval(() => {
          dots = (dots + 1) % 4;
          if (document.getElementById("loading").style.display !== "none") {
            loadingEl.textContent = `Loading contributions data${"".padEnd(
              dots,
              "."
            )}`;
          } else {
            clearInterval(app.loadingInterval);
          }
        }, 300);
      }

      function onWindowResize() {
        app.camera.aspect = window.innerWidth / window.innerHeight;
        app.camera.updateProjectionMatrix();
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        // Resize composer and bloom pass as well
        if (app.composer) {
          app.composer.setSize(window.innerWidth, window.innerHeight);
        }
         // if (app.bloomPass) { } // Handled by composer resize
      }

      function onCanvasMouseMove(event) {
        // ... (remains the same)
         const rect = app.renderer.domElement.getBoundingClientRect();
        app.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        app.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      function fetchContributionsData() {
        // ... (remains the same)
        if (app.loadingInterval) clearInterval(app.loadingInterval);
        animateLoadingText();
        generateMockData()
          .then((data) => {
            app.contributionData = data;
            document.getElementById(
              "username-display"
            ).textContent = `${data.username}'s Contributions (${data.years[0]})`;
            document.getElementById(
              "total-contributions"
            ).textContent = `Total: ${data.totalContributions} contributions`;
            createVisualization(); // Will use current theme settings
          })
          .catch((error) => {
            console.error("Failed to load contribution data:", error);
            document.getElementById("loading").textContent =
              "Failed to load data. Check console for details.";
             if (app.loadingInterval) clearInterval(app.loadingInterval);
          });
      }

      function generateMockData() {
        // ... (remains the same - generates data structure)
        return new Promise((resolve) => {
          // Simulate network delay
          setTimeout(() => {
            const days = [];
            const startDate = new Date(app.year, 0, 1);
            const endDate = new Date(app.year, 11, 31);
            let totalContribs = 0;
            let maxContribs = 0; // Find max contributions for level calculation

            // First pass to generate counts and find max
            const tempDays = [];
            for (
              let d = new Date(startDate);
              d <= endDate;
              d.setDate(d.getDate() + 1)
            ) {
              const date = d.toISOString().split("T")[0];
              const dayOfWeek = d.getDay(); // 0 = Sunday, 6 = Saturday
              const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
              const rand = Math.random();
              let count = 0;

              if (!isWeekend || rand > 0.7) {
                const baseProb = isWeekend ? 0.8 : 0.4; // Adjust probability
                if (rand > baseProb) {
                  count = Math.floor(Math.random() * 5) + 1; // Base count
                  if (rand > baseProb + 0.15)
                    count += Math.floor(Math.random() * 8);
                  if (rand > baseProb + 0.3)
                    count += Math.floor(Math.random() * 12);
                  if (rand > baseProb + 0.4) // Make level 4 more likely for Minesweeper testing
                    count += Math.floor(Math.random() * 25); // Increased range
                }
              }
              tempDays.push({ date, count, dayOfWeek });
              totalContribs += count;
              maxContribs = Math.max(maxContribs, count);
            }

            // Define contribution levels based on maxContribs (simplified quartile approach)
             // Ensure thresholds scale reasonably, even with low maxContribs
            const levelThresholds = [
                0, // Level 0 (count == 0)
                1, // Level 1 starts at count 1
                maxContribs > 5 ? Math.ceil(maxContribs * 0.20) : 2, // Level 2 threshold
                maxContribs > 10 ? Math.ceil(maxContribs * 0.45) : 5, // Level 3 threshold
                maxContribs > 15 ? Math.ceil(maxContribs * 0.70) : 10, // Level 4 threshold
            ];


            // Second pass to assign levels and calculate weekOfYear
            tempDays.forEach((tempDay) => {
              const d = new Date(tempDay.date);
              let level = 0;
              let contribLevel = "none";

              // Assign level based on count and thresholds
               if (tempDay.count >= levelThresholds[4]) {
                    level = 4;
                    contribLevel = "fourth_quartile";
                } else if (tempDay.count >= levelThresholds[3]) {
                    level = 3;
                    contribLevel = "third_quartile";
                } else if (tempDay.count >= levelThresholds[2]) {
                    level = 2;
                    contribLevel = "second_quartile";
                } else if (tempDay.count >= levelThresholds[1]) {
                    level = 1;
                    contribLevel = "first_quartile";
                }


              // Calculate week of year (consistent with GitHub)
              const firstDayOfYear = new Date(d.getFullYear(), 0, 1);
              const pastDaysOfYear = (d - firstDayOfYear) / 86400000;
              // Adjust day offset: Sunday is 0, but GitHub week starts on Sunday.
              // The calculation needs the day of the *first day* of the year.
              let weekStartDayOffset = firstDayOfYear.getDay(); // 0=Sun, 1=Mon..
              const weekOfYear = Math.floor((pastDaysOfYear + weekStartDayOffset) / 7);


              days.push({
                date: tempDay.date,
                count: tempDay.count,
                level,
                dayOfWeek: tempDay.dayOfWeek, // 0=Sun, 1=Mon...
                weekOfYear,
                contribLevel,
              });
            });

            resolve({
              username: app.username,
              totalContributions: totalContribs,
              years: [app.year],
              days,
            });
          }, 500);
        });
      }

      function createVisualization() {
        // ... (Grid calculation, ground plane, labels remain the same) ...
         if (!app.contributionData) return;

        const { days } = app.contributionData;
        const cellSize = app.config.cellSize;
        const spacing = app.config.cellSpacing;
        const totalSize = cellSize + spacing;

        const grid = {};
        let maxWeek = 0;

        // Populate grid [week][day] = contribution data
        days.forEach((day) => {
          const weekOfYear = day.weekOfYear;
          // Map dayOfWeek (0=Sun) to grid row index (0..6)
          const dayIndex = day.dayOfWeek; // 0=Sun..6=Sat
          if (weekOfYear >= 0) {
             if (!grid[weekOfYear]) grid[weekOfYear] = Array(7).fill(null); // Initialize week array
             grid[weekOfYear][dayIndex] = day;
             maxWeek = Math.max(maxWeek, weekOfYear);
          } else {
             console.warn("Invalid weekOfYear:", day.date, weekOfYear);
          }
        });

        const numWeeks = maxWeek + 1;
        const gridWidth = numWeeks * totalSize;
        const gridDepth = 7 * totalSize;
        const offsetX = -gridWidth / 2 + totalSize / 2;
        // Adjust Z offset so Sunday (day 0) is at the bottom visually
        const offsetZ = gridDepth / 2 - totalSize / 2;

        // Create ground plane
        const groundGeometry = new THREE.PlaneGeometry(gridWidth + 10, gridDepth + 10);
        const groundMaterial = new THREE.MeshLambertMaterial({
          // Use a color compatible with Minesweeper theme background
          color: app.currentTheme === 'Minesweeper' ? 0xa0a0a0 : 0x10141a,
          side: THREE.DoubleSide,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        ground.receiveShadow = true;
        app.scene.add(ground);
        app.groundPlane = ground; // Store reference for potential theme updates


        // Create contribution cells
        for (let week = 0; week <= maxWeek; week++) {
          for (let day = 0; day < 7; day++) { // day is 0 (Sun) to 6 (Sat)
            const contribution = grid[week]?.[day];
            const xPos = offsetX + week * totalSize;
            // Calculate zPos where day 0 (Sun) is at the bottom (+Z direction)
            const zPos = offsetZ - day * totalSize;
            // Only create a cell if there's data (even 0 contributions)
             if (contribution !== null) { // Check for null, not just falsy
               createContributionCell(contribution || { date: `week ${week}, day ${day}`, count: 0, level: 0, contribLevel: 'none'}, xPos, zPos); // Pass dummy data for empty cells if needed, or only create for actual days
            } else {
                 // Optionally create placeholder meshes for days before year start / after year end?
                 // For now, leave empty.
            }
          }
        }

         // Add month labels (Adjust Z position based on new layout)
        let lastMonth = -1;
        const monthLabelZ = offsetZ + totalSize * 1.5; // Position above the grid
        days.forEach((day) => {
            if (day.weekOfYear < 0) return; // Skip days with invalid week
            const date = new Date(day.date + "T00:00:00"); // Ensure UTC interpretation
            const month = date.getUTCMonth();
            const week = day.weekOfYear;
             const dayOfMonth = date.getUTCDate();

             // Place label near the start of the month (first week where day <= 7)
            if (month !== lastMonth && dayOfMonth <= 7 && week >= 0) {
                 const monthX = offsetX + week * totalSize;
                // Ensure label is created only once per month start
                 if (app.monthLabels.findIndex(label => label.userData.month === month) === -1) {
                    const label = createMonthLabel(date.toLocaleDateString("en-US", { month: "short" }), monthX, monthLabelZ);
                    label.userData = { month: month }; // Store month to prevent duplicates
                    lastMonth = month;
                 }
            }
        });

         // Add day of week labels (Adjust X position based on new layout)
        const dayLabelX = offsetX - totalSize * 1.5; // Position left of the grid
        const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        for (let day = 0; day < 7; day++) { // 0=Sun to 6=Sat
             // Adjust logic to match visual layout (e.g., show Mon, Wed, Fri)
             if (day === 1 || day === 3 || day === 5) { // Mon, Wed, Fri
                const zPos = offsetZ - day * totalSize; // Z position corresponds to the row
                createDayLabel(daysOfWeek[day], dayLabelX, zPos);
            }
        }

        document.getElementById("loading").style.display = "none";
        if (app.loadingInterval) clearInterval(app.loadingInterval);

        // Center camera (remains the same, assuming center is still 0,0,0)
        const centerTarget = new THREE.Vector3(0, 0, 0);
        new TWEEN.Tween(app.controls.target)
          .to({ x: centerTarget.x, y: centerTarget.y, z: centerTarget.z }, 800)
          .easing(TWEEN.Easing.Cubic.Out)
          .onUpdate(() => app.controls.update())
          .start();
        new TWEEN.Tween(app.camera.position)
          // Adjust camera position slightly based on grid size maybe?
          .to({ x: centerTarget.x, y: 35, z: centerTarget.z + gridDepth * 0.8 }, 1000)
          .easing(TWEEN.Easing.Cubic.Out)
          .start();
      }

      // Create a single contribution cell
      function createContributionCell(contribution, x, z) {
        const cellSize = app.config.cellSize;
         // Make base height very small for Minesweeper, slightly larger otherwise
        const baseHeight = app.currentTheme === 'Minesweeper' ? 0.01 : 0.1;
        const scaledHeight = Math.max(0, contribution.count * 0.1 * app.config.heightScale); // Ensure non-negative
        const totalHeight = baseHeight + scaledHeight;

        const geometry = new THREE.BoxGeometry(cellSize, 1, cellSize); // Height is 1, scaled later
        geometry.translate(0, 0.5, 0); // Pivot at base

        // --- Conditional Vertex Colors ---
        if (app.currentTheme !== 'Minesweeper') {
            const positionAttribute = geometry.attributes.position;
            const colors = [];
            const themeConfig = app.themes[app.currentTheme];
            const topColor = new THREE.Color(themeConfig.colors[contribution.contribLevel || 'none']);
            // Darken bottom color unless it's level 0 (already dark)
            const bottomColor = contribution.level === 0 ? topColor.clone() : topColor.clone().multiplyScalar(0.6);

            for (let i = 0; i < positionAttribute.count; i++) {
              const y = positionAttribute.getY(i);
              // Apply top color to top face vertices (y > 0 after translate), bottom color otherwise
              const color = y > 0 ? topColor : bottomColor;
              colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
        } else {
             // Ensure color attribute is removed if switching TO minesweeper from another theme
             if (geometry.attributes.color) {
                 geometry.deleteAttribute('color');
             }
        }
        // --- End Conditional Vertex Colors ---

        // Material is set by updateSingleCellMaterial based on the current theme
        const mesh = new THREE.Mesh(geometry, null); // Material assigned by updateSingleCellMaterial
        mesh.position.set(x, 0, z);
        mesh.scale.y = totalHeight;
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Shared highlight material instance (color updated by theme)
        const highlightMaterial = new THREE.MeshLambertMaterial({
            color: app.themes[app.currentTheme]?.highlightColor || app.config.highlightColor,
        });


        mesh.userData = {
          contribution: contribution,
          originalMaterial: null, // Set by updateSingleCellMaterial
          highlightMaterial: highlightMaterial, // Reuse this instance
          originalHeight: totalHeight,
        };

        // Set the initial material based on the current theme
        updateSingleCellMaterial(mesh); // Crucial step

        app.scene.add(mesh);
        app.contributionMeshes.push(mesh);
      }

      // Create month/day labels (remain the same)
      function createMonthLabel(text, x, z) {
         const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const scaleFactor = 2;
        const baseFontSize = 14;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 64 * scaleFactor;
        canvas.height = 32 * scaleFactor;
        context.fillStyle = "#c9d1d9"; // Standard color, check if needs theme adjustment
        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`;
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.imageSmoothingEnabled = true;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace; // Specify color space
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(x, 0.3, z);
        sprite.scale.set(3, 1.5, 1);
        app.scene.add(sprite);
        app.monthLabels.push(sprite);
        return sprite; // Return sprite for potential userData storage
      }

       function createDayLabel(text, x, z) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const scaleFactor = 2;
        const baseFontSize = 12;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 48 * scaleFactor;
        canvas.height = 24 * scaleFactor;
        context.fillStyle = "#c9d1d9"; // Standard color, check if needs theme adjustment
        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`;
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.imageSmoothingEnabled = true;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace; // Specify color space
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(x, 0.3, z);
        sprite.scale.set(2.5, 1.25, 1);
        app.scene.add(sprite);
        app.weekLabels.push(sprite);
       }


      // Update heights
      function updateHeights() {
         const baseHeight = app.currentTheme === 'Minesweeper' ? 0.01 : 0.1;
        app.contributionMeshes.forEach((mesh) => {
          const { contribution } = mesh.userData;
          const scaledHeight = Math.max(0, contribution.count * 0.1 * app.config.heightScale);
          const newTotalHeight = baseHeight + scaledHeight;
           // Animate height change? Optional.
           // new TWEEN.Tween(mesh.scale).to({ y: newTotalHeight }, 300).easing(TWEEN.Easing.Quadratic.Out).start();
          mesh.scale.y = newTotalHeight; // Direct update for now
        });
      }

      // Clear scene (Update to dispose materials AND textures)
      function clearScene() {
        // Remove contribution meshes and dispose materials/geometry
        while (app.contributionMeshes.length > 0) {
            const mesh = app.contributionMeshes.pop();
            if (mesh.parent) mesh.parent.remove(mesh);
             if (mesh.geometry) mesh.geometry.dispose();
             // Dispose the current material
             if (mesh.material) mesh.material.dispose();
            // Dispose the stored original material (might be the same instance)
            if (mesh.userData.originalMaterial) mesh.userData.originalMaterial.dispose();
            // Dispose the highlight material (if unique instances were created, otherwise careful)
             // Since we reuse the highlightMaterial instance, only dispose if sure it's not needed
             // Or better: don't dispose highlightMaterial here, manage it separately if needed.
             // Let's assume highlightMaterial instance is managed elsewhere or reused.
            mesh.userData = null; // Help GC
        }
        app.contributionMeshes = [];

        // Remove month labels and dispose textures/materials
        while (app.monthLabels.length > 0) {
          const label = app.monthLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          if (label.material) label.material.dispose();
        }
         app.monthLabels = [];

        // Remove day labels and dispose textures/materials
        while (app.weekLabels.length > 0) {
          const label = app.weekLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          if (label.material) label.material.dispose();
        }
        app.weekLabels = [];

        // Remove ground plane
         if (app.groundPlane) {
            if (app.groundPlane.parent) app.groundPlane.parent.remove(app.groundPlane);
            if (app.groundPlane.geometry) app.groundPlane.geometry.dispose();
            if (app.groundPlane.material) app.groundPlane.material.dispose();
            app.groundPlane = null;
        }

        // Dispose Minesweeper textures if they exist
        // Don't dispose here if switching themes, only when unloading fully?
        // Let's dispose them here for a clean slate on data reload.
        disposeMinesweeperTextures();


        // Reset hover info
        document.getElementById("hover-info").textContent = "Hover over a cell to see details";
        app.hoveredCell = null;
      }


      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        app.controls.update();
        TWEEN.update();

        // --- Raycasting ---
        app.raycaster.setFromCamera(app.mouse, app.camera);
        const intersects = app.raycaster.intersectObjects(app.contributionMeshes, false);

        let intersectedObject = null;
        if (intersects.length > 0) {
            // Find the first intersected object that is a contribution cell
             for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object?.userData?.contribution) {
                    intersectedObject = intersects[i].object;
                    break;
                }
            }
        }


        // Handle hover out
        if (app.hoveredCell && app.hoveredCell !== intersectedObject) {
             // Restore the THEMED original material only if it exists
            if (app.hoveredCell.userData?.originalMaterial) {
                 // Check if material still exists (might have been disposed during theme switch/clear)
                try {
                    app.hoveredCell.material = app.hoveredCell.userData.originalMaterial;
                } catch (e) {
                    console.warn("Failed to restore original material, likely disposed.", e);
                     // Optionally try to re-apply material based on current theme
                     // updateSingleCellMaterial(app.hoveredCell);
                }

            } else {
                 console.warn("Hovered out cell missing original material reference.");
            }
            app.hoveredCell = null;
            document.getElementById("hover-info").textContent = "Hover over a cell to see details";
        }

        // Handle hover in
        if (intersectedObject && app.hoveredCell !== intersectedObject) {
            // Ensure previous hover is cleared BEFORE applying new highlight
            if (app.hoveredCell && app.hoveredCell.userData?.originalMaterial) {
                 try {
                    app.hoveredCell.material = app.hoveredCell.userData.originalMaterial;
                 } catch(e) { /* ignore if disposed */ }
            }

            app.hoveredCell = intersectedObject;
            // Apply THEMED highlight material
            if (app.hoveredCell.userData?.highlightMaterial) {
                 // Ensure highlight material color is up-to-date with current theme
                const themeConfig = app.themes[app.currentTheme];
                app.hoveredCell.userData.highlightMaterial.color.set(
                     app.currentTheme === 'Minesweeper'
                         ? themeConfig.cellHighlightColor
                         : (themeConfig.highlightColor || app.config.highlightColor)
                 );
                app.hoveredCell.material = app.hoveredCell.userData.highlightMaterial;
            } else {
                 console.warn("Hovered cell missing highlight material reference.");
            }


            // Update info display
            const { contribution } = app.hoveredCell.userData;
            if (contribution) {
                 const date = new Date(contribution.date + "T00:00:00"); // Use UTC date
                const formattedDate = date.toLocaleDateString("en-US", { timeZone: 'UTC', weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                document.getElementById("hover-info").innerHTML = `<strong>${formattedDate}</strong><br>${contribution.count} contribution${contribution.count !== 1 ? 's' : ''}`;
            } else {
                 document.getElementById("hover-info").textContent = "No data for this cell.";
            }

        }
        // --- End Raycasting ---


        // --- Conditional Rendering ---
        if (app.currentTheme === "Glow" && app.composer && app.bloomPass?.enabled) {
          app.composer.render(); // Use composer for Glow theme
        } else {
          app.renderer.render(app.scene, app.camera); // Use direct renderer otherwise
        }
        // --- End Conditional Rendering ---
      }


      // == OrbitControls Implementation ==
      // [ ... OrbitControls code remains exactly the same ... ]
      // == OrbitControls Implementation ==
      // Using a slightly modified version to ensure compatibility and avoid global conflicts
      THREE.OrbitControls = function (object, domElement) {
        this.object = object;

        this.domElement = domElement !== undefined ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.05;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = false; // if true, pan in screen-space
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = {
          LEFT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.DOLLY,
          RIGHT: THREE.MOUSE.PAN,
        };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {
          return spherical.phi;
        };

        this.getAzimuthalAngle = function () {
          return spherical.theta;
        };

        this.saveState = function () {
          scope.target0.copy(scope.target);
          scope.position0.copy(scope.object.position);
          scope.zoom0 = scope.object.zoom;
        };

        this.reset = function () {
          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;

          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);

          scope.update();

          state = STATE.NONE;
        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = (function () {
          var offset = new THREE.Vector3();

          // so camera.up is the orbit axis
          var quat = new THREE.Quaternion().setFromUnitVectors(
            object.up,
            new THREE.Vector3(0, 1, 0)
          );
          var quatInverse = quat.clone().invert();

          var lastPosition = new THREE.Vector3();
          var lastQuaternion = new THREE.Quaternion();

          return function update() {
            var position = scope.object.position;

            offset.copy(position).sub(scope.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis
            spherical.setFromVector3(offset);

            if (scope.autoRotate && state === STATE.NONE) {
              rotateLeft(getAutoRotationAngle());
            }

            if (scope.enableDamping) {
              spherical.theta += sphericalDelta.theta * scope.dampingFactor;
              spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
              spherical.theta += sphericalDelta.theta;
              spherical.phi += sphericalDelta.phi;
            }

            // restrict theta to be between desired limits
            spherical.theta = Math.max(
              scope.minAzimuthAngle,
              Math.min(scope.maxAzimuthAngle, spherical.theta)
            );

            // restrict phi to be between desired limits
            spherical.phi = Math.max(
              scope.minPolarAngle,
              Math.min(scope.maxPolarAngle, spherical.phi)
            );

            spherical.makeSafe();

            spherical.radius *= scale;

            // restrict radius to be between desired limits
            spherical.radius = Math.max(
              scope.minDistance,
              Math.min(scope.maxDistance, spherical.radius)
            );

            // move target to panned location

            if (scope.enableDamping === true) {
              scope.target.addScaledVector(panOffset, scope.dampingFactor);
            } else {
              scope.target.add(panOffset);
            }

            offset.setFromSpherical(spherical);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(scope.target).add(offset);

            scope.object.lookAt(scope.target);

            if (scope.enableDamping === true) {
              sphericalDelta.theta *= 1 - scope.dampingFactor;
              sphericalDelta.phi *= 1 - scope.dampingFactor;

              panOffset.multiplyScalar(1 - scope.dampingFactor);
            } else {
              sphericalDelta.set(0, 0, 0);

              panOffset.set(0, 0, 0);
            }

            scale = 1;

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (
              zoomChanged ||
              lastPosition.distanceToSquared(scope.object.position) > EPS ||
              8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
            ) {
              scope.dispatchEvent(changeEvent);

              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;

              return true;
            }

            return false;
          };
        })();

        this.dispose = function () {
          scope.domElement.removeEventListener(
            "contextmenu",
            onContextMenu,
            false
          );
          scope.domElement.removeEventListener("mousedown", onMouseDown, false);
          scope.domElement.removeEventListener("wheel", onMouseWheel, false);

          scope.domElement.removeEventListener(
            "touchstart",
            onTouchStart,
            false
          );
          scope.domElement.removeEventListener("touchend", onTouchEnd, false);
          scope.domElement.removeEventListener("touchmove", onTouchMove, false);

          document.removeEventListener("mousemove", onDocumentMouseMove, false); // Use correct name
          document.removeEventListener("mouseup", onDocumentMouseUp, false); // Use correct name

          window.removeEventListener("keydown", onKeyDown, false); // Listen on window

          //scope.dispatchEvent( { type: 'dispose' } ); // should be added to code base according to https://github.com/mrdoob/three.js/pull/1517
        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: "change" };
        var startEvent = { type: "start" };
        var endEvent = { type: "end" };

        var STATE = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_DOLLY_PAN: 4,
        }; // Adjusted states slightly

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();

        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {
          return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
        }

        function getZoomScale() {
          return Math.pow(0.95, scope.zoomSpeed);
        }

        function rotateLeft(angle) {
          sphericalDelta.theta -= angle;
        }

        function rotateUp(angle) {
          sphericalDelta.phi -= angle;
        }

        var panLeft = (function () {
          var v = new THREE.Vector3();

          return function panLeft(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
            v.multiplyScalar(-distance);

            panOffset.add(v);
          };
        })();

        var panUp = (function () {
          var v = new THREE.Vector3();

          return function panUp(distance, objectMatrix) {
            if (scope.screenSpacePanning === true) {
              v.setFromMatrixColumn(objectMatrix, 1);
            } else {
              v.setFromMatrixColumn(objectMatrix, 0);
              v.crossVectors(scope.object.up, v);
            }

            v.multiplyScalar(distance);

            panOffset.add(v);
          };
        })();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = (function () {
          var offset = new THREE.Vector3();

          return function pan(deltaX, deltaY) {
            var element =
              scope.domElement === document
                ? scope.domElement.body
                : scope.domElement;

            if (scope.object.isPerspectiveCamera) {
              // perspective
              var position = scope.object.position;
              offset.copy(position).sub(scope.target);
              var targetDistance = offset.length();

              // half of the fov is center to top of screen
              targetDistance *= Math.tan(
                ((scope.object.fov / 2) * Math.PI) / 180.0
              );

              // we use only clientHeight here so aspect ratio does not distort speed
              panLeft(
                (2 * deltaX * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
              panUp(
                (2 * deltaY * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
            } else if (scope.object.isOrthographicCamera) {
              // orthographic
              panLeft(
                (deltaX * (scope.object.right - scope.object.left)) /
                  scope.object.zoom /
                  element.clientWidth,
                scope.object.matrix
              );
              panUp(
                (deltaY * (scope.object.top - scope.object.bottom)) /
                  scope.object.zoom /
                  element.clientHeight,
                scope.object.matrix
              );
            } else {
              // camera neither orthographic nor perspective
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
              );
              scope.enablePan = false;
            }
          };
        })();

        function dollyIn(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale /= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom * dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        function dollyOut(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale *= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom / dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate(event) {
          rotateStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownDolly(event) {
          dollyStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownPan(event) {
          panStart.set(event.clientX, event.clientY);
        }

        function handleMouseMoveRotate(event) {
          rotateEnd.set(event.clientX, event.clientY);

          rotateDelta
            .subVectors(rotateEnd, rotateStart)
            .multiplyScalar(scope.rotateSpeed);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height

          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleMouseMoveDolly(event) {
          dollyEnd.set(event.clientX, event.clientY);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {
            dollyIn(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyOut(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleMouseMovePan(event) {
          panEnd.set(event.clientX, event.clientY);

          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        // Renamed handler for document mouse up
        function onDocumentMouseUp(/*event*/) {
          if (scope.enabled === false) return;

          document.removeEventListener("mousemove", onDocumentMouseMove, false);
          document.removeEventListener("mouseup", onDocumentMouseUp, false);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        // Renamed handler for document mouse move
        function onDocumentMouseMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          if (state === STATE.ROTATE) {
            if (scope.enableRotate === false) return;
            handleMouseMoveRotate(event);
          } else if (state === STATE.DOLLY) {
             if (scope.enableZoom === false) return;
            handleMouseMoveDolly(event);
          } else if (state === STATE.PAN) {
             if (scope.enablePan === false) return;
            handleMouseMovePan(event);
          }
        }

        function onMouseDown(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          switch (event.button) {
            case scope.mouseButtons.LEFT: // Default: Rotate
                 // Modifier check for Pan (Shift/Ctrl/Meta)
                 if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    if (scope.enablePan === false) return;
                    handleMouseDownPan(event);
                    state = STATE.PAN;
                 } else { // No modifier: Rotate
                    if (scope.enableRotate === false) return;
                    handleMouseDownRotate(event);
                    state = STATE.ROTATE;
                 }
                break;

            case scope.mouseButtons.MIDDLE: // Default: Dolly
              if (scope.enableZoom === false) return;
              handleMouseDownDolly(event);
              state = STATE.DOLLY;
              break;

            case scope.mouseButtons.RIGHT: // Default: Pan
              if (scope.enablePan === false) return;
              handleMouseDownPan(event);
              state = STATE.PAN;
              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            // Add renamed listeners to document
            document.addEventListener("mousemove", onDocumentMouseMove, false);
            document.addEventListener("mouseup", onDocumentMouseUp, false);

            scope.dispatchEvent(startEvent);
          }
        }

        function onMouseWheel(event) {
          if (
            scope.enabled === false ||
            scope.enableZoom === false ||
            (state !== STATE.NONE && state !== STATE.ROTATE) // Allow zoom while rotating? Maybe not.
          )
            return;

          event.preventDefault();
          event.stopPropagation();

          scope.dispatchEvent(startEvent);
          handleMouseWheel(event);
          scope.dispatchEvent(endEvent);
        }

        function handleMouseWheel(event) {
             // Normalize deltaY value across browsers
            let delta = 0;
            if (event.wheelDelta) { // Old WebKit
                delta = -event.wheelDelta / 120;
            } else if (event.deltaY) { // Modern standard
                delta = event.deltaY / 3; // Adjust sensitivity?
            }

            if (delta < 0) {
                dollyOut(getZoomScale());
            } else if (delta > 0) {
                dollyIn(getZoomScale());
            }

          scope.update();
        }

        function onKeyDown(event) {
          if (
            scope.enabled === false ||
            scope.enableKeys === false ||
            scope.enablePan === false
          )
            return;

          handleKeyDown(event);
        }

        function handleKeyDown(event) {
          var needsUpdate = false;

          switch (event.keyCode) {
            case scope.keys.UP:
              pan(0, scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.BOTTOM:
              pan(0, -scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.LEFT:
              pan(scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;

            case scope.keys.RIGHT:
              pan(-scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;
          }

          if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            event.preventDefault();
            scope.update();
          }
        }

        function onTouchStart(event) {
          if (scope.enabled === false) return;

          event.preventDefault(); // Prevent scrolling.

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;
              handleTouchStartRotate(event);
              state = STATE.TOUCH_ROTATE;
              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false) return;
              handleTouchStartDollyPan(event);
              state = STATE.TOUCH_DOLLY_PAN;
              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            scope.dispatchEvent(startEvent);
          }
        }

        function handleTouchStartRotate(event) {
          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchStartDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            panStart.set(x, y);
          }
        }

        function onTouchMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();
          event.stopPropagation();

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;
              if (state !== STATE.TOUCH_ROTATE) return;
              handleTouchMoveRotate(event);
              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false) return;
              if (state !== STATE.TOUCH_DOLLY_PAN) return;
              handleTouchMoveDollyPan(event);
              break;

            default:
              state = STATE.NONE;
          }
        }

        function handleTouchMoveRotate(event) {
          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
          var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height
          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);
          rotateStart.copy(rotateEnd);
          scope.update();
        }

        function handleTouchMoveDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed)); // Calculate dolly delta
            dollyIn(dollyDelta.y); // Apply dolly
            dollyStart.copy(dollyEnd); // Update start point
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            panEnd.set(x, y);
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
          }
          scope.update();
        }


        function onTouchEnd(/*event*/) {
          if (scope.enabled === false) return;
          scope.dispatchEvent(endEvent);
          state = STATE.NONE;
        }

        function onContextMenu(event) {
          if (scope.enabled === false) return;
          event.preventDefault();
        }

        // Add event listeners to the domElement
        scope.domElement.addEventListener("contextmenu", onContextMenu, false);
        scope.domElement.addEventListener("mousedown", onMouseDown, false);
        scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false }); // Use passive: false if calling preventDefault

        scope.domElement.addEventListener("touchstart", onTouchStart, { passive: false }); // Use passive: false
        scope.domElement.addEventListener("touchend", onTouchEnd, false);
        scope.domElement.addEventListener("touchmove", onTouchMove, { passive: false }); // Use passive: false

        // Listen to window for keydown event
        window.addEventListener("keydown", onKeyDown, false);

        // force an update at start
        this.update();
      };

      THREE.OrbitControls.prototype = Object.create(
        THREE.EventDispatcher.prototype
      );
      THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

      // Start application
      init();
      animate();
    </script>
  </body>
</html>