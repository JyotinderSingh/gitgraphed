<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Contributions 3D Map</title>
    <style>
      /* ... (keep existing styles) ... */
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #0d1117;
        color: #c9d1d9;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 20px;
        background: rgba(13, 17, 23, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
      }
      canvas {
        display: block;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      button,
      input {
        background: #21262d;
        border: 1px solid #30363d;
        color: #c9d1d9;
        padding: 6px 12px;
        border-radius: 6px;
        margin: 5px;
        cursor: pointer;
      }
      button:hover {
        background: #30363d;
      }
      label {
        margin-left: 10px;
      }
      /* Style for dat.GUI */
      .dg.main {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 200; /* Ensure it's above other elements */
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading contributions data...</div>
    <div id="info">
      <h2 id="username-display">GitHub Contributions</h2>
      <div id="hover-info">Hover over a cell to see details</div>
      <div id="total-contributions"></div>
    </div>
    <div id="controls">
      <div>
        <label for="username">Username:</label>
        <input type="text" id="username" placeholder="GitHub username" />
        <label for="year">Year:</label>
        <input type="number" id="year" min="2008" max="2025" />
        <button id="load-data">Load Data</button>
      </div>
      <div>
        <button id="reset-camera">Reset Camera</button>
        <input type="checkbox" id="auto-rotate" checked />
        <label for="auto-rotate">Auto Rotate</label>
        <input
          type="range"
          id="height-scale"
          min="0.1"
          max="3"
          step="0.1"
          value="1"
        />
        <label for="height-scale">Height Scale</label>
      </div>
    </div>

    <!-- Include Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Post-processing scripts -->
    <!-- Make sure these paths are correct or use CDN links if available -->
    <!-- Example using local paths (replace with your actual paths or CDNs) -->
    <script src="js/vendor/three/postprocessing/EffectComposer.js"></script>
    <script src="js/vendor/three/postprocessing/RenderPass.js"></script>
    <script src="js/vendor/three/postprocessing/ShaderPass.js"></script>
    <script src="js/vendor/three/shaders/CopyShader.js"></script>
    <script src="js/vendor/three/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/vendor/three/postprocessing/UnrealBloomPass.js"></script>
    <!-- Include dat.GUI and Tween.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
      // Main application
      const app = {
        scene: null,
        camera: null,
        renderer: null,
        controls: null,
        composer: null, // For post-processing
        bloomPass: null, // Reference to the bloom pass
        gui: null, // For dat.GUI controls
        raycaster: new THREE.Raycaster(),
        mouse: new THREE.Vector2(),
        contributionData: null,
        contributionMeshes: [],
        weekLabels: [],
        monthLabels: [],
        config: {
          cellSize: 1,
          cellSpacing: 0.2,
          heightScale: 1,
          autoRotate: true,
          baseColor: 0x0d1117,
          colors: {
            none: 0x161b22,
            first_quartile: 0x0e4429,
            second_quartile: 0x006d32,
            third_quartile: 0x26a641,
            fourth_quartile: 0x39d353,
          },
          highlightColor: 0xffcc00,
        },
        hoveredCell: null,
        username: "torvalds", // Default username
        year: new Date().getFullYear(), // Default year is current year

        // --- Theme Management ---
        currentTheme: "Standard", // Default theme
        themes: {
          Standard: {
            name: "Standard",
          },
          Glow: {
            name: "Glow",
            // Store theme-specific settings if needed
            bloomStrength: 1.0,
            bloomRadius: 0.8,
            bloomThreshold: 0.3,
            toneMappingExposure: 1.5,
            emissiveIntensity: 0.1,
          },
          // Add more themes here later
          // Example:
          // 'Minimal': {
          //     name: 'Minimal',
          //     /* settings */
          // }
        },
        themeSettings: {
          // This object will be controlled by dat.GUI
          theme: "Standard",
        },
        // --- End Theme Management ---
      };

      // Initialize the application
      function init() {
        setupThreeJS();
        setupPostProcessing(); // Setup composer and passes
        setupGUI(); // Setup dat.GUI controls
        setupEventListeners();
        setupInitialValues();
        applyTheme(app.currentTheme); // Apply the initial theme
        animateLoadingText();
        fetchContributionsData();
      }

      // Setup Three.js scene, camera, renderer, lights, controls
      function setupThreeJS() {
        // Create scene
        app.scene = new THREE.Scene();
        app.scene.background = new THREE.Color(app.config.baseColor);

        // Create camera
        app.camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        app.camera.position.set(0, 30, 40);
        app.camera.lookAt(0, 0, 0);

        // Create renderer
        app.renderer = new THREE.WebGLRenderer({ antialias: true });
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        app.renderer.shadowMap.enabled = true;
        // Tone mapping will be set by applyTheme
        // app.renderer.toneMapping = THREE.ReinhardToneMapping;
        // app.renderer.toneMappingExposure = 1.5;
        document.body.appendChild(app.renderer.domElement);

        // Add lights (remains the same)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        app.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 150;
        app.scene.add(directionalLight);

        // OrbitControls (remains the same)
        app.controls = new THREE.OrbitControls(
          app.camera,
          app.renderer.domElement
        );
        app.controls.enableDamping = true;
        app.controls.dampingFactor = 0.05;
        app.controls.screenSpacePanning = false;
        app.controls.minDistance = 10;
        app.controls.maxDistance = 100;
        app.controls.maxPolarAngle = Math.PI / 1.8;

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);
      }

      // Setup Post-Processing Effects (Composer and Passes)
      function setupPostProcessing() {
        app.composer = new THREE.EffectComposer(app.renderer);

        const renderPass = new THREE.RenderPass(app.scene, app.camera);
        app.composer.addPass(renderPass);

        // Initialize bloom pass but its parameters will be set by the theme
        app.bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.0, // strength (will be overridden by theme)
          0.5, // radius (will be overridden by theme)
          0.3 // threshold (will be overridden by theme)
        );
        app.composer.addPass(app.bloomPass);

        // Initially disable bloom pass if default theme is not Glow
        app.bloomPass.enabled = app.currentTheme === "Glow";
      }

       // Setup dat.GUI controls
       function setupGUI() {
        app.gui = new dat.GUI();
        app.gui.domElement.classList.add('main'); // Optional: for specific styling

        // Get theme names for the dropdown
        const themeNames = Object.keys(app.themes);

        // Add theme selection controller
        app.gui.add(app.themeSettings, 'theme', themeNames)
          .name('Theme')
          .onChange((value) => {
            applyTheme(value);
          });

        // Optional: Add controls for Glow theme parameters if you want runtime tuning
        // const glowFolder = app.gui.addFolder('Glow Settings');
        // glowFolder.add(app.themes.Glow, 'bloomThreshold', 0.0, 1.0).onChange(value => { if (app.currentTheme === 'Glow') app.bloomPass.threshold = value; });
        // glowFolder.add(app.themes.Glow, 'bloomStrength', 0.0, 3.0).onChange(value => { if (app.currentTheme === 'Glow') app.bloomPass.strength = value; });
        // glowFolder.add(app.themes.Glow, 'bloomRadius', 0.0, 1.0).onChange(value => { if (app.currentTheme === 'Glow') app.bloomPass.radius = value; });
        // glowFolder.add(app.themes.Glow, 'toneMappingExposure', 0.1, 2.0).onChange(value => { if (app.currentTheme === 'Glow') app.renderer.toneMappingExposure = value; });
        // glowFolder.add(app.themes.Glow, 'emissiveIntensity', 0.0, 1.0).onChange(value => { if (app.currentTheme === 'Glow') updateAllCellMaterials(); });
        // glowFolder.open(); // Optional: Open the folder by default
      }

      // Apply a specific theme
      function applyTheme(themeName) {
        if (!app.themes[themeName]) {
          console.warn(`Theme "${themeName}" not found.`);
          return;
        }

        console.log(`Applying theme: ${themeName}`);
        app.currentTheme = themeName;
        app.themeSettings.theme = themeName; // Sync GUI state if changed programmatically

        const isGlow = themeName === "Glow";
        const glowConfig = app.themes.Glow; // Get glow settings

        // 1. Update Renderer Settings
        app.renderer.toneMapping = isGlow
          ? THREE.ReinhardToneMapping
          : THREE.NoToneMapping; // Or LinearToneMapping if preferred for Standard
        app.renderer.toneMappingExposure = isGlow
          ? glowConfig.toneMappingExposure
          : 1.0; // Default exposure

        // 2. Update Post-processing Settings
        if (app.bloomPass) {
          app.bloomPass.enabled = isGlow;
          if (isGlow) {
            // Apply specific settings from the theme definition
            app.bloomPass.threshold = glowConfig.bloomThreshold;
            app.bloomPass.strength = glowConfig.bloomStrength;
            app.bloomPass.radius = glowConfig.bloomRadius;
          }
        }

        // 3. Update Materials of Existing Cells
        updateAllCellMaterials();

        // Force GUI update if needed (usually updates automatically)
        if (app.gui) {
            app.gui.__controllers.forEach(controller => {
                if (controller.property === 'theme') {
                    controller.updateDisplay();
                }
            });
        }
      }

      // Update materials for all contribution cells based on the current theme
      function updateAllCellMaterials() {
        // console.log("Updating materials for theme:", app.currentTheme);
        app.contributionMeshes.forEach(mesh => {
          updateSingleCellMaterial(mesh);
        });
      }

      // Update material for a single cell
      function updateSingleCellMaterial(mesh) {
        if (!mesh || !mesh.userData || !mesh.userData.contribution) return;

        const { contribution } = mesh.userData;
        const isGlow = app.currentTheme === "Glow";
        const glowConfig = app.themes.Glow;
        const topColor = new THREE.Color(app.config.colors[contribution.contribLevel]);

        // Dispose previous material to prevent memory leaks
        if (mesh.material) {
          mesh.material.dispose();
        }
        // Also dispose the stored original material if it exists
         if (mesh.userData.originalMaterial && mesh.userData.originalMaterial !== mesh.material) {
            mesh.userData.originalMaterial.dispose();
        }

        // Create new material based on theme
        const newMaterial = new THREE.MeshLambertMaterial({
          vertexColors: true, // Keep vertex colors for gradient
          emissive: isGlow ? topColor : 0x000000, // Only set emissive for Glow theme
          emissiveIntensity: isGlow ? glowConfig.emissiveIntensity : 0,
        });

        mesh.material = newMaterial;
        mesh.userData.originalMaterial = newMaterial; // Store reference for hover reset

         // We don't need to re-assign highlightMaterial unless it also needs theming
        // mesh.userData.highlightMaterial remains the simple yellow Lambert material
      }

      function setupEventListeners() {
        // Mouse move for raycasting
        app.renderer.domElement.addEventListener(
          "mousemove",
          onCanvasMouseMove,
          false
        );

        // Button event listeners (remain the same)
        document.getElementById("load-data").addEventListener("click", () => {
          const usernameInput = document.getElementById("username").value;
          const yearInput = document.getElementById("year").value;

          if (usernameInput) {
            app.username = usernameInput;
          }
          if (yearInput && !isNaN(parseInt(yearInput))) {
            app.year = parseInt(yearInput);
          }

          document.getElementById("loading").style.display = "block";
          clearScene();
          fetchContributionsData(); // This will recreate cells with the current theme
        });

        document
          .getElementById("reset-camera")
          .addEventListener("click", () => {
             // Reset camera position with animation (remains the same)
            new TWEEN.Tween(app.camera.position)
              .to({ x: 0, y: 30, z: 40 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
            new TWEEN.Tween(app.controls.target)
              .to({ x: 0, y: 0, z: 0 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .onUpdate(() => app.controls.update())
              .start();
          });

        document
          .getElementById("auto-rotate")
          .addEventListener("change", (e) => {
            app.config.autoRotate = e.target.checked;
            app.controls.autoRotate = app.config.autoRotate;
          });

        document
          .getElementById("height-scale")
          .addEventListener("input", (e) => {
            app.config.heightScale = parseFloat(e.target.value);
            updateHeights(); // Height update is independent of theme material
          });
      }

      function setupInitialValues() {
        document.getElementById("username").value = app.username;
        document.getElementById("year").value = app.year;
        app.controls.autoRotate = app.config.autoRotate;
        document.getElementById("auto-rotate").checked = app.config.autoRotate;
        app.controls.target.set(0, 0, 0); // This line should no longer cause an error
        app.controls.update();
      }

      function animateLoadingText() {
        // ... (remains the same)
         const loadingEl = document.getElementById("loading");
        let dots = 0;
        if (app.loadingInterval) clearInterval(app.loadingInterval); // Clear previous interval if any
        app.loadingInterval = setInterval(() => {
          dots = (dots + 1) % 4;
          if (document.getElementById("loading").style.display !== "none") {
            loadingEl.textContent = `Loading contributions data${"".padEnd(
              dots,
              "."
            )}`;
          } else {
            clearInterval(app.loadingInterval);
          }
        }, 300);
      }

      function onWindowResize() {
        app.camera.aspect = window.innerWidth / window.innerHeight;
        app.camera.updateProjectionMatrix();
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        // Resize composer and bloom pass as well
        if (app.composer) {
          app.composer.setSize(window.innerWidth, window.innerHeight);
        }
         if (app.bloomPass) {
            // UnrealBloomPass might need specific handling or EffectComposer handles it
            // For safety, explicitly set size if required by the pass implementation
             // bloomPass.setSize(window.innerWidth, window.innerHeight); // Check if needed
        }
      }

      function onCanvasMouseMove(event) {
        // ... (remains the same)
         const rect = app.renderer.domElement.getBoundingClientRect();
        app.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        app.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      function fetchContributionsData() {
        // ... (remains the same)
        if (app.loadingInterval) clearInterval(app.loadingInterval);
        animateLoadingText();
        generateMockData()
          .then((data) => {
            app.contributionData = data;
            document.getElementById(
              "username-display"
            ).textContent = `${data.username}'s Contributions (${data.years[0]})`;
            document.getElementById(
              "total-contributions"
            ).textContent = `Total: ${data.totalContributions} contributions`;
            createVisualization(); // Will use current theme settings
          })
          .catch((error) => {
            console.error("Failed to load contribution data:", error);
            document.getElementById("loading").textContent =
              "Failed to load data. Check console for details.";
             if (app.loadingInterval) clearInterval(app.loadingInterval);
          });
      }

      function generateMockData() {
        // ... (remains the same - generates data structure)
        return new Promise((resolve) => {
          // Simulate network delay
          setTimeout(() => {
            const days = [];
            const startDate = new Date(app.year, 0, 1);
            const endDate = new Date(app.year, 11, 31);
            let totalContribs = 0;
            let maxContribs = 0; // Find max contributions for level calculation

            // First pass to generate counts and find max
            const tempDays = [];
            for (
              let d = new Date(startDate);
              d <= endDate;
              d.setDate(d.getDate() + 1)
            ) {
              const date = d.toISOString().split("T")[0];
              const dayOfWeek = d.getDay(); // 0 = Sunday, 6 = Saturday
              const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
              const rand = Math.random();
              let count = 0;

              if (!isWeekend || rand > 0.7) {
                const baseProb = isWeekend ? 0.8 : 0.4; // Adjust probability
                if (rand > baseProb) {
                  count = Math.floor(Math.random() * 5) + 1; // Base count
                  if (rand > baseProb + 0.15)
                    count += Math.floor(Math.random() * 8);
                  if (rand > baseProb + 0.3)
                    count += Math.floor(Math.random() * 12);
                  if (rand > baseProb + 0.4)
                    count += Math.floor(Math.random() * 15);
                }
              }
              tempDays.push({ date, count, dayOfWeek });
              totalContribs += count;
              maxContribs = Math.max(maxContribs, count);
            }

            // Define contribution levels based on maxContribs (simplified quartile approach)
            const levelThresholds = [
              0, // Level 0
              maxContribs > 0 ? Math.ceil(maxContribs * 0.01) : 1, // Level 1 threshold (at least 1)
              maxContribs > 0 ? Math.ceil(maxContribs * 0.25) : 2, // Level 2 threshold
              maxContribs > 0 ? Math.ceil(maxContribs * 0.5) : 3, // Level 3 threshold
              maxContribs > 0 ? Math.ceil(maxContribs * 0.75) : 4, // Level 4 threshold
            ];

            // Second pass to assign levels and calculate weekOfYear
            tempDays.forEach((tempDay) => {
              const d = new Date(tempDay.date);
              let level = 0;
              let contribLevel = "none";

              if (tempDay.count > levelThresholds[4]) {
                level = 4;
                contribLevel = "fourth_quartile";
              } else if (tempDay.count > levelThresholds[3]) {
                level = 3;
                contribLevel = "third_quartile";
              } else if (tempDay.count > levelThresholds[2]) {
                level = 2;
                contribLevel = "second_quartile";
              } else if (tempDay.count > levelThresholds[1]) {
                level = 1;
                contribLevel = "first_quartile";
              } else if (tempDay.count > levelThresholds[0]) {
                 level = 1; // Assign level 1 even for 1 contribution if threshold is > 1
                 contribLevel = "first_quartile";
              }
              // Refined check: Ensure count > 0 gets at least level 1, handle maxContribs=0 case
               if (tempDay.count > 0 && level === 0) {
                   level = 1;
                   contribLevel = "first_quartile";
               }


              // Calculate week of year (consistent with GitHub)
              const firstDayOfYear = new Date(d.getFullYear(), 0, 1);
              const pastDaysOfYear = (d - firstDayOfYear) / 86400000;
              const weekOfYear = Math.floor(
                (pastDaysOfYear + firstDayOfYear.getDay()) / 7
              );

              days.push({
                date: tempDay.date,
                count: tempDay.count,
                level,
                dayOfWeek: tempDay.dayOfWeek,
                weekOfYear,
                contribLevel,
              });
            });

            resolve({
              username: app.username,
              totalContributions: totalContribs,
              years: [app.year],
              days,
            });
          }, 500);
        });
      }

      function createVisualization() {
        // ... (Grid calculation, ground plane, labels remain the same) ...
         if (!app.contributionData) return;

        const { days } = app.contributionData;
        const cellSize = app.config.cellSize;
        const spacing = app.config.cellSpacing;
        const totalSize = cellSize + spacing;

        const grid = {};
        let maxWeek = 0;

        days.forEach((day) => {
          const weekOfYear = day.weekOfYear;
          const dayOfWeek = day.dayOfWeek;
          if (weekOfYear >= 0) {
            if (!grid[weekOfYear]) grid[weekOfYear] = {};
            grid[weekOfYear][dayOfWeek] = day;
            maxWeek = Math.max(maxWeek, weekOfYear);
          } else {
             console.warn("Invalid weekOfYear:", day.date, weekOfYear);
          }
        });

        const numWeeks = maxWeek + 1;
        const gridWidth = numWeeks * totalSize;
        const gridDepth = 7 * totalSize;
        const offsetX = -gridWidth / 2 + totalSize / 2;
        const offsetZ = -gridDepth / 2 + totalSize / 2;

        // Create ground plane
        const groundGeometry = new THREE.PlaneGeometry(gridWidth + 10, gridDepth + 10);
        const groundMaterial = new THREE.MeshLambertMaterial({
          color: 0x10141a, // Slightly lighter than base background
          side: THREE.DoubleSide,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        ground.receiveShadow = true;
        app.scene.add(ground);

        // Create contribution cells
        for (let week = 0; week <= maxWeek; week++) {
          for (let day = 0; day < 7; day++) {
            const contribution = grid[week]?.[day];
            const xPos = offsetX + week * totalSize;
            const zPos = offsetZ + day * totalSize;
            if (contribution) {
              createContributionCell(contribution, xPos, zPos); // Will create cell with current theme material
            }
          }
        }

         // Add month labels
        let lastMonth = -1;
        const monthLabelZ = offsetZ + 7 * totalSize + totalSize * 0.5;
        days.forEach((day) => {
            const date = new Date(day.date + "T00:00:00");
            const month = date.getMonth();
            const week = day.weekOfYear;
            const dayOfMonth = date.getDate();
            if (month !== lastMonth && dayOfMonth <= 7 && week >= 0) {
                const monthX = offsetX + week * totalSize;
                createMonthLabel(date.toLocaleDateString("en-US", { month: "short" }), monthX, monthLabelZ);
                lastMonth = month;
            }
        });

        // Add day of week labels
        const dayLabelX = offsetX - totalSize * 1.5;
        const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        for (let day = 0; day < 7; day++) {
            if (day === 1 || day === 3 || day === 5) { // Mon, Wed, Fri
                createDayLabel(daysOfWeek[day], dayLabelX, offsetZ + day * totalSize);
            }
        }

        document.getElementById("loading").style.display = "none";
        if (app.loadingInterval) clearInterval(app.loadingInterval);

        // Center camera (remains the same)
        const centerTarget = new THREE.Vector3(0, 0, 0);
        new TWEEN.Tween(app.controls.target)
          .to({ x: centerTarget.x, y: centerTarget.y, z: centerTarget.z }, 800)
          .easing(TWEEN.Easing.Cubic.Out)
          .onUpdate(() => app.controls.update())
          .start();
        new TWEEN.Tween(app.camera.position)
          .to({ x: centerTarget.x, y: 35, z: centerTarget.z + gridDepth * 0.8 }, 1000)
          .easing(TWEEN.Easing.Cubic.Out)
          .start();
      }

      // Create a single contribution cell
      function createContributionCell(contribution, x, z) {
        const cellSize = app.config.cellSize;
        const baseHeight = 0.1;
        const scaledHeight = contribution.count * 0.1 * app.config.heightScale;
        const totalHeight = baseHeight + scaledHeight;

        const geometry = new THREE.BoxGeometry(cellSize, 1, cellSize);
        geometry.translate(0, 0.5, 0);

        // --- Vertex Colors for Gradient ---
        const positionAttribute = geometry.attributes.position;
        const colors = [];
        const topColor = new THREE.Color(app.config.colors[contribution.contribLevel]);
        const bottomColor = contribution.level === 0 ? topColor.clone() : topColor.clone().multiplyScalar(0.6);
        for (let i = 0; i < positionAttribute.count; i++) {
          const y = positionAttribute.getY(i);
          colors.push( (y > 0 ? topColor : bottomColor).r, (y > 0 ? topColor : bottomColor).g, (y > 0 ? topColor : bottomColor).b);
        }
        geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
        // --- End Vertex Colors ---

        // Material is set by updateSingleCellMaterial based on the current theme
        const mesh = new THREE.Mesh(geometry, null); // Material will be assigned shortly
        mesh.position.set(x, 0, z);
        mesh.scale.y = totalHeight;
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Simple material for highlighting (independent of theme for now)
         const highlightMaterial = new THREE.MeshLambertMaterial({
            color: app.config.highlightColor,
            // No emissive for highlight unless desired
        });


        mesh.userData = {
          contribution: contribution,
          originalMaterial: null, // Will be set by updateSingleCellMaterial
          highlightMaterial: highlightMaterial,
          originalHeight: totalHeight,
        };

        // Set the initial material based on the current theme
        updateSingleCellMaterial(mesh); // Crucial step

        app.scene.add(mesh);
        app.contributionMeshes.push(mesh);
      }

      // Create month/day labels (remain the same)
      function createMonthLabel(text, x, z) {
         const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const scaleFactor = 2;
        const baseFontSize = 14;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 64 * scaleFactor;
        canvas.height = 32 * scaleFactor;
        context.fillStyle = "#c9d1d9";
        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`;
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.imageSmoothingEnabled = true;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(x, 0.3, z);
        sprite.scale.set(3, 1.5, 1);
        app.scene.add(sprite);
        app.monthLabels.push(sprite);
      }

       function createDayLabel(text, x, z) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const scaleFactor = 2;
        const baseFontSize = 12;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 48 * scaleFactor;
        canvas.height = 24 * scaleFactor;
        context.fillStyle = "#c9d1d9";
        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`;
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.imageSmoothingEnabled = true;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(x, 0.3, z);
        sprite.scale.set(2.5, 1.25, 1);
        app.scene.add(sprite);
        app.weekLabels.push(sprite);
      }


      // Update heights (remains the same)
      function updateHeights() {
        const baseHeight = 0.1;
        app.contributionMeshes.forEach((mesh) => {
          const { contribution } = mesh.userData;
          const scaledHeight = contribution.count * 0.1 * app.config.heightScale;
          const newTotalHeight = baseHeight + scaledHeight;
          mesh.scale.y = newTotalHeight;
        });
      }

      // Clear scene (Update to dispose materials properly)
      function clearScene() {
        // Remove contribution meshes and dispose materials
        while (app.contributionMeshes.length > 0) {
            const mesh = app.contributionMeshes.pop();
            if (mesh.parent) mesh.parent.remove(mesh);
            mesh.geometry.dispose();
            // Dispose the current material
            if (mesh.material) mesh.material.dispose();
            // Dispose the stored original material (might be the same instance, but dispose is safe)
            if (mesh.userData.originalMaterial) mesh.userData.originalMaterial.dispose();
            // Dispose the highlight material
            if (mesh.userData.highlightMaterial) mesh.userData.highlightMaterial.dispose();
        }
        app.contributionMeshes = []; // Ensure array is empty

        // Remove month labels
        while (app.monthLabels.length > 0) {
          const label = app.monthLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          label.material.dispose();
        }
         app.monthLabels = [];

        // Remove day labels
        while (app.weekLabels.length > 0) {
          const label = app.weekLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          label.material.dispose();
        }
        app.weekLabels = [];

        // Remove ground plane and other potential objects
        const objectsToRemove = app.scene.children.filter(child =>
            child instanceof THREE.Mesh && child.geometry instanceof THREE.PlaneGeometry
        );
        objectsToRemove.forEach(child => {
            if (child.parent) child.parent.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });

        // Reset hover info
        document.getElementById("hover-info").textContent = "Hover over a cell to see details";
        app.hoveredCell = null;
      }


      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        app.controls.update();
        TWEEN.update();

        // --- Raycasting (remains mostly the same) ---
        app.raycaster.setFromCamera(app.mouse, app.camera);
        const intersects = app.raycaster.intersectObjects(app.contributionMeshes, false);

        let intersectedObject = null;
        if (intersects.length > 0) {
            for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object.userData?.contribution) {
                    intersectedObject = intersects[i].object;
                    break;
                }
            }
        }

        // Handle hover out
        if (app.hoveredCell && app.hoveredCell !== intersectedObject) {
            // Restore the THEMED original material
            if (app.hoveredCell.userData?.originalMaterial) {
                app.hoveredCell.material = app.hoveredCell.userData.originalMaterial;
            }
            app.hoveredCell = null;
            document.getElementById("hover-info").textContent = "Hover over a cell to see details";
        }

        // Handle hover in
        if (intersectedObject && app.hoveredCell !== intersectedObject) {
             // Ensure previous hover is cleared BEFORE applying new highlight
            if (app.hoveredCell && app.hoveredCell.userData?.originalMaterial) {
                 app.hoveredCell.material = app.hoveredCell.userData.originalMaterial;
            }

            app.hoveredCell = intersectedObject;
            // Apply highlight material
            if (app.hoveredCell.userData?.highlightMaterial) {
                app.hoveredCell.material = app.hoveredCell.userData.highlightMaterial;
            }

            // Update info display
            const { contribution } = app.hoveredCell.userData;
            const date = new Date(contribution.date + "T00:00:00");
            const formattedDate = date.toLocaleDateString("en-US", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            document.getElementById("hover-info").innerHTML = `<strong>${formattedDate}</strong><br>${contribution.count} contribution${contribution.count !== 1 ? 's' : ''}`;
        }
        // --- End Raycasting ---


        // --- Conditional Rendering ---
        if (app.currentTheme === "Glow" && app.composer && app.bloomPass?.enabled) {
          app.composer.render(); // Use composer for Glow theme
        } else {
          app.renderer.render(app.scene, app.camera); // Use direct renderer otherwise
        }
        // --- End Conditional Rendering ---
      }


      // == OrbitControls Implementation ==
      // == OrbitControls Implementation ==
      // Using a slightly modified version to ensure compatibility and avoid global conflicts
      THREE.OrbitControls = function (object, domElement) {
        this.object = object;

        this.domElement = domElement !== undefined ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.05;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = false; // if true, pan in screen-space
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = {
          LEFT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.DOLLY,
          RIGHT: THREE.MOUSE.PAN,
        };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {
          return spherical.phi;
        };

        this.getAzimuthalAngle = function () {
          return spherical.theta;
        };

        this.saveState = function () {
          scope.target0.copy(scope.target);
          scope.position0.copy(scope.object.position);
          scope.zoom0 = scope.object.zoom;
        };

        this.reset = function () {
          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;

          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);

          scope.update();

          state = STATE.NONE;
        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = (function () {
          var offset = new THREE.Vector3();

          // so camera.up is the orbit axis
          var quat = new THREE.Quaternion().setFromUnitVectors(
            object.up,
            new THREE.Vector3(0, 1, 0)
          );
          var quatInverse = quat.clone().invert();

          var lastPosition = new THREE.Vector3();
          var lastQuaternion = new THREE.Quaternion();

          return function update() {
            var position = scope.object.position;

            offset.copy(position).sub(scope.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis
            spherical.setFromVector3(offset);

            if (scope.autoRotate && state === STATE.NONE) {
              rotateLeft(getAutoRotationAngle());
            }

            if (scope.enableDamping) {
              spherical.theta += sphericalDelta.theta * scope.dampingFactor;
              spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
              spherical.theta += sphericalDelta.theta;
              spherical.phi += sphericalDelta.phi;
            }

            // restrict theta to be between desired limits
            spherical.theta = Math.max(
              scope.minAzimuthAngle,
              Math.min(scope.maxAzimuthAngle, spherical.theta)
            );

            // restrict phi to be between desired limits
            spherical.phi = Math.max(
              scope.minPolarAngle,
              Math.min(scope.maxPolarAngle, spherical.phi)
            );

            spherical.makeSafe();

            spherical.radius *= scale;

            // restrict radius to be between desired limits
            spherical.radius = Math.max(
              scope.minDistance,
              Math.min(scope.maxDistance, spherical.radius)
            );

            // move target to panned location

            if (scope.enableDamping === true) {
              scope.target.addScaledVector(panOffset, scope.dampingFactor);
            } else {
              scope.target.add(panOffset);
            }

            offset.setFromSpherical(spherical);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(scope.target).add(offset);

            scope.object.lookAt(scope.target);

            if (scope.enableDamping === true) {
              sphericalDelta.theta *= 1 - scope.dampingFactor;
              sphericalDelta.phi *= 1 - scope.dampingFactor;

              panOffset.multiplyScalar(1 - scope.dampingFactor);
            } else {
              sphericalDelta.set(0, 0, 0);

              panOffset.set(0, 0, 0);
            }

            scale = 1;

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (
              zoomChanged ||
              lastPosition.distanceToSquared(scope.object.position) > EPS ||
              8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
            ) {
              scope.dispatchEvent(changeEvent);

              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;

              return true;
            }

            return false;
          };
        })();

        this.dispose = function () {
          scope.domElement.removeEventListener(
            "contextmenu",
            onContextMenu,
            false
          );
          scope.domElement.removeEventListener("mousedown", onMouseDown, false);
          scope.domElement.removeEventListener("wheel", onMouseWheel, false);

          scope.domElement.removeEventListener(
            "touchstart",
            onTouchStart,
            false
          );
          scope.domElement.removeEventListener("touchend", onTouchEnd, false);
          scope.domElement.removeEventListener("touchmove", onTouchMove, false);

          document.removeEventListener("mousemove", onDocumentMouseMove, false); // Use correct name
          document.removeEventListener("mouseup", onDocumentMouseUp, false); // Use correct name

          scope.domElement.removeEventListener("keydown", onKeyDown, false);

          //scope.dispatchEvent( { type: 'dispose' } ); // should be added to code base according to https://github.com/mrdoob/three.js/pull/1517
        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: "change" };
        var startEvent = { type: "start" };
        var endEvent = { type: "end" };

        var STATE = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_DOLLY_PAN: 4,
        }; // Adjusted states slightly

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();

        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {
          return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
        }

        function getZoomScale() {
          return Math.pow(0.95, scope.zoomSpeed);
        }

        function rotateLeft(angle) {
          sphericalDelta.theta -= angle;
        }

        function rotateUp(angle) {
          sphericalDelta.phi -= angle;
        }

        var panLeft = (function () {
          var v = new THREE.Vector3();

          return function panLeft(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
            v.multiplyScalar(-distance);

            panOffset.add(v);
          };
        })();

        var panUp = (function () {
          var v = new THREE.Vector3();

          return function panUp(distance, objectMatrix) {
            if (scope.screenSpacePanning === true) {
              v.setFromMatrixColumn(objectMatrix, 1);
            } else {
              v.setFromMatrixColumn(objectMatrix, 0);
              v.crossVectors(scope.object.up, v);
            }

            v.multiplyScalar(distance);

            panOffset.add(v);
          };
        })();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = (function () {
          var offset = new THREE.Vector3();

          return function pan(deltaX, deltaY) {
            var element =
              scope.domElement === document
                ? scope.domElement.body
                : scope.domElement;

            if (scope.object.isPerspectiveCamera) {
              // perspective
              var position = scope.object.position;
              offset.copy(position).sub(scope.target);
              var targetDistance = offset.length();

              // half of the fov is center to top of screen
              targetDistance *= Math.tan(
                ((scope.object.fov / 2) * Math.PI) / 180.0
              );

              // we use only clientHeight here so aspect ratio does not distort speed
              panLeft(
                (2 * deltaX * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
              panUp(
                (2 * deltaY * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
            } else if (scope.object.isOrthographicCamera) {
              // orthographic
              panLeft(
                (deltaX * (scope.object.right - scope.object.left)) /
                  scope.object.zoom /
                  element.clientWidth,
                scope.object.matrix
              );
              panUp(
                (deltaY * (scope.object.top - scope.object.bottom)) /
                  scope.object.zoom /
                  element.clientHeight,
                scope.object.matrix
              );
            } else {
              // camera neither orthographic nor perspective
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
              );
              scope.enablePan = false;
            }
          };
        })();

        function dollyIn(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale /= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom * dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        function dollyOut(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale *= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom / dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate(event) {
          rotateStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownDolly(event) {
          dollyStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownPan(event) {
          panStart.set(event.clientX, event.clientY);
        }

        function handleMouseMoveRotate(event) {
          rotateEnd.set(event.clientX, event.clientY);

          rotateDelta
            .subVectors(rotateEnd, rotateStart)
            .multiplyScalar(scope.rotateSpeed);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height

          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleMouseMoveDolly(event) {
          dollyEnd.set(event.clientX, event.clientY);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {
            dollyIn(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyOut(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleMouseMovePan(event) {
          panEnd.set(event.clientX, event.clientY);

          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        // Renamed handler for document mouse up
        function onDocumentMouseUp(/*event*/) {
          if (scope.enabled === false) return;

          document.removeEventListener("mousemove", onDocumentMouseMove, false);
          document.removeEventListener("mouseup", onDocumentMouseUp, false);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        // Renamed handler for document mouse move
        function onDocumentMouseMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          if (state === STATE.ROTATE) {
            handleMouseMoveRotate(event);
          } else if (state === STATE.DOLLY) {
            handleMouseMoveDolly(event);
          } else if (state === STATE.PAN) {
            handleMouseMovePan(event);
          }
        }

        function onMouseDown(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          switch (event.button) {
            case scope.mouseButtons.LEFT:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (scope.enablePan === false) return;

                handleMouseDownPan(event);

                state = STATE.PAN;
              } else {
                if (scope.enableRotate === false) return;

                handleMouseDownRotate(event);

                state = STATE.ROTATE;
              }

              break;

            case scope.mouseButtons.MIDDLE:
              if (scope.enableZoom === false) return;

              handleMouseDownDolly(event);

              state = STATE.DOLLY;

              break;

            case scope.mouseButtons.RIGHT:
              if (scope.enablePan === false) return;

              handleMouseDownPan(event);

              state = STATE.PAN;

              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            // Add renamed listeners to document
            document.addEventListener("mousemove", onDocumentMouseMove, false);
            document.addEventListener("mouseup", onDocumentMouseUp, false);

            scope.dispatchEvent(startEvent);
          }
        }

        function onMouseWheel(event) {
          if (
            scope.enabled === false ||
            scope.enableZoom === false ||
            (state !== STATE.NONE && state !== STATE.ROTATE)
          )
            return;

          event.preventDefault();
          event.stopPropagation();

          scope.dispatchEvent(startEvent);

          handleMouseWheel(event);

          scope.dispatchEvent(endEvent);
        }

        function handleMouseWheel(event) {
          if (event.deltaY < 0) {
            dollyOut(getZoomScale());
          } else if (event.deltaY > 0) {
            dollyIn(getZoomScale());
          }

          scope.update();
        }

        function onKeyDown(event) {
          if (
            scope.enabled === false ||
            scope.enableKeys === false ||
            scope.enablePan === false
          )
            return;

          handleKeyDown(event);
        }

        function handleKeyDown(event) {
          var needsUpdate = false;

          switch (event.keyCode) {
            case scope.keys.UP:
              pan(0, scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.BOTTOM:
              pan(0, -scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.LEFT:
              pan(scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;

            case scope.keys.RIGHT:
              pan(-scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;
          }

          if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            event.preventDefault();

            scope.update();
          }
        }

        function onTouchStart(event) {
          if (scope.enabled === false) return;

          event.preventDefault(); // Prevent scrolling.

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;

              handleTouchStartRotate(event);

              state = STATE.TOUCH_ROTATE;

              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false)
                return;

              handleTouchStartDollyPan(event);

              state = STATE.TOUCH_DOLLY_PAN;

              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            scope.dispatchEvent(startEvent);
          }
        }

        function handleTouchStartRotate(event) {
          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchStartDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;

            var distance = Math.sqrt(dx * dx + dy * dy);

            dollyStart.set(0, distance);
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

            panStart.set(x, y);
          }
        }

        function onTouchMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();
          event.stopPropagation();

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;
              if (state !== STATE.TOUCH_ROTATE) return; // is this needed?

              handleTouchMoveRotate(event);

              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              if (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?

              handleTouchMoveDollyPan(event);

              break;

            default:
              state = STATE.NONE;
          }
        }

        function handleTouchMoveRotate(event) {
          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);

          rotateDelta
            .subVectors(rotateEnd, rotateStart)
            .multiplyScalar(scope.rotateSpeed);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height

          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleTouchMoveDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;

            var distance = Math.sqrt(dx * dx + dy * dy);

            dollyEnd.set(0, distance);

            dollyDelta.set(
              0,
              Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed)
            );

            dollyIn(dollyDelta.y);

            dollyStart.copy(dollyEnd);
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

            panEnd.set(x, y);

            panDelta
              .subVectors(panEnd, panStart)
              .multiplyScalar(scope.panSpeed);

            pan(panDelta.x, panDelta.y);

            panStart.copy(panEnd);
          }

          scope.update();
        }

        function onTouchEnd(/*event*/) {
          if (scope.enabled === false) return;

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        function onContextMenu(event) {
          if (scope.enabled === false) return;

          event.preventDefault();
        }

        // Add event listeners to the domElement
        scope.domElement.addEventListener("contextmenu", onContextMenu, false);

        scope.domElement.addEventListener("mousedown", onMouseDown, false);
        scope.domElement.addEventListener("wheel", onMouseWheel, false);

        scope.domElement.addEventListener("touchstart", onTouchStart, false);
        scope.domElement.addEventListener("touchend", onTouchEnd, false);
        scope.domElement.addEventListener("touchmove", onTouchMove, false);

        // Listen to window for keydown event
        window.addEventListener("keydown", onKeyDown, false); // Changed from scope.domElement

        // force an update at start
        this.update();
      };

      THREE.OrbitControls.prototype = Object.create(
        THREE.EventDispatcher.prototype
      );
      THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

      // Add event for Vector3 clamp
      // (This seems unnecessary as Vector3 already has clamp, min, max methods in r128)
      // THREE.Vector3.prototype.clamp = function(min, max) {
      //     this.x = Math.max(min.x, Math.min(max.x, this.x));
      //     this.y = Math.max(min.y, Math.min(max.y, this.y));
      //     this.z = Math.max(min.z, Math.min(max.z, this.z));
      //     return this;
      // };

      // Start application
      init();
      animate();
    </script>
  </body>
</html>