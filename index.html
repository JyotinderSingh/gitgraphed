<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Contributions 3D Map</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #0d1117;
        color: #c9d1d9;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 20px;
        background: rgba(13, 17, 23, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
      }
      canvas {
        display: block;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(13, 17, 23, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      button,
      input {
        background: #21262d;
        border: 1px solid #30363d;
        color: #c9d1d9;
        padding: 6px 12px;
        border-radius: 6px;
        margin: 5px;
        cursor: pointer;
      }
      button:hover {
        background: #30363d;
      }
      label {
        margin-left: 10px;
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading contributions data...</div>
    <div id="info">
      <h2 id="username-display">GitHub Contributions</h2>
      <div id="hover-info">Hover over a cell to see details</div>
      <div id="total-contributions"></div>
    </div>
    <div id="controls">
      <div>
        <label for="username">Username:</label>
        <input type="text" id="username" placeholder="GitHub username" />
        <label for="year">Year:</label>
        <input type="number" id="year" min="2008" max="2025" />
        <button id="load-data">Load Data</button>
      </div>
      <div>
        <button id="reset-camera">Reset Camera</button>
        <input type="checkbox" id="auto-rotate" checked />
        <label for="auto-rotate">Auto Rotate</label>
        <input
          type="range"
          id="height-scale"
          min="0.1"
          max="3"
          step="0.1"
          value="1"
        />
        <label for="height-scale">Height Scale</label>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="js/vendor/three/postprocessing/EffectComposer.js"></script>
    <script src="js/vendor/three/postprocessing/RenderPass.js"></script>
    <script src="js/vendor/three/postprocessing/ShaderPass.js"></script>
    <script src="js/vendor/three/shaders/CopyShader.js"></script>
    <script src="js/vendor/three/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/vendor/three/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
      // Main application
      const app = {
        scene: null,
        camera: null,
        renderer: null,
        controls: null,
        composer: null,
        raycaster: new THREE.Raycaster(),
        mouse: new THREE.Vector2(),
        contributionData: null,
        contributionMeshes: [],
        weekLabels: [],
        monthLabels: [],
        config: {
          cellSize: 1,
          cellSpacing: 0.2,
          heightScale: 1,
          autoRotate: true,
          baseColor: 0x0d1117,
          // Green shades, darker for more contributions (GitHub style)
          colors: {
            none: 0x161b22, // Dark grey for no contributions
            first_quartile: 0x0e4429, // Darkest green
            second_quartile: 0x006d32, // Medium green
            third_quartile: 0x26a641, // Brighter green
            fourth_quartile: 0x39d353, // Brightest green
          },
          highlightColor: 0xffcc00, // Changed highlight to yellow for better contrast
        },
        hoveredCell: null,
        username: "torvalds", // Default username
        year: new Date().getFullYear(), // Default year is current year
      };

      // Initialize the application
      function init() {
        setupThreeJS();
        setupEventListeners();
        setupInitialValues();
        animateLoadingText();
        fetchContributionsData();
      }

      // Setup Three.js scene
      function setupThreeJS() {
        // Create scene
        app.scene = new THREE.Scene();
        app.scene.background = new THREE.Color(app.config.baseColor);

        // Create camera
        app.camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        app.camera.position.set(0, 30, 40);
        app.camera.lookAt(0, 0, 0);

        // Create renderer
        app.renderer = new THREE.WebGLRenderer({ antialias: true });
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        app.renderer.shadowMap.enabled = true;

        // Tone mapping can improve bloom appearance
        app.renderer.toneMapping = THREE.ReinhardToneMapping;
        app.renderer.toneMappingExposure = 1.5; // Adjust exposure if needed

        document.body.appendChild(app.renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Slightly increased ambient light
        app.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); // Slightly increased directional light
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        // Adjust shadow camera bounds if needed
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 150;
        app.scene.add(directionalLight);
        // Optional: Add a light helper
        // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
        // app.scene.add(shadowHelper);

        // OrbitControls for camera manipulation
        app.controls = new THREE.OrbitControls(
          app.camera,
          app.renderer.domElement
        );
        app.controls.enableDamping = true;
        app.controls.dampingFactor = 0.05;
        app.controls.screenSpacePanning = false;
        app.controls.minDistance = 10;
        app.controls.maxDistance = 100;
        app.controls.maxPolarAngle = Math.PI / 1.8; // Slightly allow looking more from top down

        // Post-processing Setup
        app.composer = new THREE.EffectComposer(app.renderer);

        // 1. Render Pass - Renders the original scene
        const renderPass = new THREE.RenderPass(app.scene, app.camera);
        app.composer.addPass(renderPass);

        // 2. Unreal Bloom Pass - Adds the glow effect
        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5, // strength - Adjust this (lower = subtler)
          0.4, // radius - Adjust this (controls spread)
          0.85 // threshold - Adjust this (lower = more things glow)
        );
        // --- Tune these bloom parameters ---
        bloomPass.threshold = 0.3; // <-- Lower this drastically first (e.g., 0.1 to 0.5)
            bloomPass.strength = 1.0;  // <-- Ensure strength isn't zero (e.g., 0.8 to 1.5)
            bloomPass.radius = 0.5;    // <-- Keep radius reasonable (e.g., 0.3 to 0.8)
        // --- End Tuning ---

        app.composer.addPass(bloomPass);

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);
      }

      function setupEventListeners() {
        // Mouse move for raycasting - Use renderer.domElement to avoid conflicts
        app.renderer.domElement.addEventListener(
          "mousemove",
          onCanvasMouseMove,
          false
        );

        // Button event listeners
        document.getElementById("load-data").addEventListener("click", () => {
          const usernameInput = document.getElementById("username").value;
          const yearInput = document.getElementById("year").value;

          if (usernameInput) {
            app.username = usernameInput;
          }

          if (yearInput && !isNaN(parseInt(yearInput))) {
            app.year = parseInt(yearInput);
          }

          document.getElementById("loading").style.display = "block";
          clearScene();
          fetchContributionsData();
        });

        document
          .getElementById("reset-camera")
          .addEventListener("click", () => {
            // Reset camera position with animation
            new TWEEN.Tween(app.camera.position)
              .to({ x: 0, y: 30, z: 40 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();

            new TWEEN.Tween(app.controls.target)
              .to({ x: 0, y: 0, z: 0 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .onUpdate(() => app.controls.update()) // Ensure controls update during tween
              .start();
          });

        document
          .getElementById("auto-rotate")
          .addEventListener("change", (e) => {
            app.config.autoRotate = e.target.checked;
            app.controls.autoRotate = app.config.autoRotate;
          });

        document
          .getElementById("height-scale")
          .addEventListener("input", (e) => {
            app.config.heightScale = parseFloat(e.target.value);
            updateHeights();
          });
      }

      function setupInitialValues() {
        document.getElementById("username").value = app.username;
        document.getElementById("year").value = app.year;
        app.controls.autoRotate = app.config.autoRotate;
        document.getElementById("auto-rotate").checked = app.config.autoRotate;
        app.controls.target.set(0, 0, 0); // Ensure target starts at 0,0,0
        app.controls.update(); // Initialize controls state
      }

      function animateLoadingText() {
        const loadingEl = document.getElementById("loading");
        let dots = 0;
        // Store interval ID to clear it later if needed
        app.loadingInterval = setInterval(() => {
          dots = (dots + 1) % 4;
          if (document.getElementById("loading").style.display !== "none") {
            loadingEl.textContent = `Loading contributions data${"".padEnd(
              dots,
              "."
            )}`;
          } else {
            clearInterval(app.loadingInterval); // Stop animation when loading is hidden
          }
        }, 300);
      }

      // Handle window resize
      function onWindowResize() {
        app.camera.aspect = window.innerWidth / window.innerHeight;
        app.camera.updateProjectionMatrix();
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        if (app.composer) {
          app.composer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      // Mouse move handler for raycasting (on canvas)
      function onCanvasMouseMove(event) {
        // Calculate mouse position relative to the canvas
        const rect = app.renderer.domElement.getBoundingClientRect();
        app.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        app.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      // Fetch GitHub contribution data
      function fetchContributionsData() {
        // Re-enable loading text animation if needed
        if (app.loadingInterval) clearInterval(app.loadingInterval);
        animateLoadingText();

        // In a real application, you would fetch this from your backend
        generateMockData()
          .then((data) => {
            app.contributionData = data;
            document.getElementById(
              "username-display"
            ).textContent = `${data.username}'s Contributions (${data.years[0]})`;
            document.getElementById(
              "total-contributions"
            ).textContent = `Total: ${data.totalContributions} contributions`;
            createVisualization();
          })
          .catch((error) => {
            console.error("Failed to load contribution data:", error);
            document.getElementById("loading").textContent =
              "Failed to load data. Check console for details.";
            // Optionally keep loading indicator visible or show error message
          });
      }

      // Generate mock data for demo purposes
      function generateMockData() {
        return new Promise((resolve) => {
          // Simulate network delay
          setTimeout(() => {
            const days = [];
            const startDate = new Date(app.year, 0, 1);
            const endDate = new Date(app.year, 11, 31);
            let totalContribs = 0;
            let maxContribs = 0; // Find max contributions for level calculation

            // First pass to generate counts and find max
            const tempDays = [];
            for (
              let d = new Date(startDate);
              d <= endDate;
              d.setDate(d.getDate() + 1)
            ) {
              const date = d.toISOString().split("T")[0];
              const dayOfWeek = d.getDay(); // 0 = Sunday, 6 = Saturday
              const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
              const rand = Math.random();
              let count = 0;

              if (!isWeekend || rand > 0.7) {
                const baseProb = isWeekend ? 0.8 : 0.4; // Adjust probability
                if (rand > baseProb) {
                  count = Math.floor(Math.random() * 5) + 1; // Base count
                  if (rand > baseProb + 0.15)
                    count += Math.floor(Math.random() * 8);
                  if (rand > baseProb + 0.3)
                    count += Math.floor(Math.random() * 12);
                  if (rand > baseProb + 0.4)
                    count += Math.floor(Math.random() * 15);
                }
              }
              tempDays.push({ date, count, dayOfWeek });
              totalContribs += count;
              maxContribs = Math.max(maxContribs, count);
            }

            // Define contribution levels based on maxContribs (simplified quartile approach)
            const levelThresholds = [
              0, // Level 0
              maxContribs > 0 ? Math.ceil(maxContribs * 0.01) : 1, // Level 1 threshold (at least 1)
              maxContribs > 0 ? Math.ceil(maxContribs * 0.25) : 2, // Level 2 threshold
              maxContribs > 0 ? Math.ceil(maxContribs * 0.5) : 3, // Level 3 threshold
              maxContribs > 0 ? Math.ceil(maxContribs * 0.75) : 4, // Level 4 threshold
            ];

            // Second pass to assign levels and calculate weekOfYear
            tempDays.forEach((tempDay) => {
              const d = new Date(tempDay.date);
              let level = 0;
              let contribLevel = "none";

              if (tempDay.count > levelThresholds[4]) {
                level = 4;
                contribLevel = "fourth_quartile";
              } else if (tempDay.count > levelThresholds[3]) {
                level = 3;
                contribLevel = "third_quartile";
              } else if (tempDay.count > levelThresholds[2]) {
                level = 2;
                contribLevel = "second_quartile";
              } else if (tempDay.count > levelThresholds[1]) {
                level = 1;
                contribLevel = "first_quartile";
              } else if (tempDay.count > levelThresholds[0]) {
                level = 1;
                contribLevel = "first_quartile";
              } // Ensure count > 0 gets at least level 1

              // Calculate week of year (consistent with GitHub)
              const firstDayOfYear = new Date(d.getFullYear(), 0, 1);
              const pastDaysOfYear = (d - firstDayOfYear) / 86400000;
              // Adjust start day for week calculation (Sunday as start of week)
              const weekOfYear = Math.floor(
                (pastDaysOfYear + firstDayOfYear.getDay()) / 7
              );

              days.push({
                date: tempDay.date,
                count: tempDay.count,
                level,
                dayOfWeek: tempDay.dayOfWeek,
                weekOfYear,
                contribLevel,
              });
            });

            resolve({
              username: app.username,
              totalContributions: totalContribs,
              years: [app.year],
              days,
            });
          }, 500); // Reduced mock delay
        });
      }

      // Create the 3D visualization from contribution data
      function createVisualization() {
        if (!app.contributionData) return;

        const { days } = app.contributionData;
        const cellSize = app.config.cellSize;
        const spacing = app.config.cellSpacing;
        const totalSize = cellSize + spacing;

        // Group days by week and day of week for grid layout
        const grid = {};
        let maxWeek = 0;

        days.forEach((day) => {
          const weekOfYear = day.weekOfYear;
          const dayOfWeek = day.dayOfWeek; // 0=Sun, 6=Sat

          // Ensure week index is valid
          if (weekOfYear >= 0) {
            if (!grid[weekOfYear]) {
              grid[weekOfYear] = {};
            }
            grid[weekOfYear][dayOfWeek] = day;
            maxWeek = Math.max(maxWeek, weekOfYear);
          } else {
            console.warn(
              "Invalid weekOfYear calculated:",
              day.date,
              weekOfYear
            );
          }
        });

        // Calculate grid dimensions and center offset
        const numWeeks = maxWeek + 1;
        const gridWidth = numWeeks * totalSize;
        const gridDepth = 7 * totalSize; // Use depth for Z-axis
        const offsetX = -gridWidth / 2 + totalSize / 2;
        const offsetZ = -gridDepth / 2 + totalSize / 2;

        // Create a ground plane (optional, helps with orientation)
        const groundGeometry = new THREE.PlaneGeometry(
          gridWidth + 10,
          gridDepth + 10
        );
        const groundMaterial = new THREE.MeshLambertMaterial({
          // Use Lambert for lighting interaction
          color: app.config.baseColor, // Slightly lighter than background
          side: THREE.DoubleSide,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1; // Position slightly below cells
        ground.receiveShadow = true; // Allow ground to receive shadows
        app.scene.add(ground);

        // Create contribution cells
        for (let week = 0; week <= maxWeek; week++) {
          for (let day = 0; day < 7; day++) {
            // Position cells based on week (X) and dayOfWeek (Z)
            // GitHub map usually has Sunday at the top (low Z) or bottom (high Z)
            // Let's map Sun (0) to Z=0, Sat (6) to Z=6
            const contribution = grid[week]?.[day];
            const xPos = offsetX + week * totalSize;
            const zPos = offsetZ + day * totalSize;

            if (contribution) {
              createContributionCell(contribution, xPos, zPos);
            } else {
              // Optionally create a placeholder for missing days if needed
              // createContributionCell({ date: `Week ${week}, Day ${day}`, count: 0, level: 0, contribLevel: 'none'}, xPos, zPos);
            }
          }
        }

        // Add month labels on x-axis (below the grid)
        let lastMonth = -1;
        const monthLabelZ = offsetZ + 7 * totalSize + totalSize * 0.5; // Position below last day row
        days.forEach((day) => {
          const date = new Date(day.date + "T00:00:00"); // Ensure correct date parsing
          const month = date.getMonth();
          const week = day.weekOfYear;
          const dayOfMonth = date.getDate();

          // Add month label near the start of the month's first full week
          if (month !== lastMonth && dayOfMonth <= 7 && week >= 0) {
            const monthX = offsetX + week * totalSize;
            createMonthLabel(
              date.toLocaleDateString("en-US", { month: "short" }),
              monthX,
              monthLabelZ
            );
            lastMonth = month;
          }
        });

        // Add day of week labels on z-axis (left of the grid)
        const dayLabelX = offsetX - totalSize * 1.5; // Position left of first week column
        const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        // Adjust label positioning if needed based on day mapping
        for (let day = 0; day < 7; day++) {
          if (day === 1 || day === 3 || day === 5) {
            // Show only Mon, Wed, Fri
            createDayLabel(
              daysOfWeek[day],
              dayLabelX,
              offsetZ + day * totalSize // Z position corresponds to day row
            );
          }
        }

        // Hide loading indicator
        document.getElementById("loading").style.display = "none";
        if (app.loadingInterval) clearInterval(app.loadingInterval); // Stop loading animation

        // Center camera view on the grid
        const centerTarget = new THREE.Vector3(0, 0, 0); // Center of the grid
        new TWEEN.Tween(app.controls.target)
          .to({ x: centerTarget.x, y: centerTarget.y, z: centerTarget.z }, 800)
          .easing(TWEEN.Easing.Cubic.Out)
          .onUpdate(() => app.controls.update())
          .start();
        new TWEEN.Tween(app.camera.position)
          .to(
            { x: centerTarget.x, y: 35, z: centerTarget.z + gridDepth * 0.8 },
            1000
          ) // Adjust camera distance based on grid size
          .easing(TWEEN.Easing.Cubic.Out)
          .start();
      }

      // Create a single contribution cell with gradient
      function createContributionCell(contribution, x, z) {
        const cellSize = app.config.cellSize;
        // Ensure minimum height for visibility, scale actual height based on count
        const baseHeight = 0.1;
        const scaledHeight = contribution.count * 0.1 * app.config.heightScale; // Adjusted scaling factor
        const totalHeight = baseHeight + scaledHeight;

        const geometry = new THREE.BoxGeometry(cellSize, 1, cellSize); // Use height 1 for easier scaling/vertex access
        geometry.translate(0, 0.5, 0); // Move origin to base of the box

        const positionAttribute = geometry.attributes.position;
        const colors = [];
        const topColor = new THREE.Color(
          app.config.colors[contribution.contribLevel]
        );
        // Make bottom color slightly darker for gradient effect, except for 'none' level
        const bottomColor =
          contribution.level === 0
            ? topColor.clone()
            : topColor.clone().multiplyScalar(0.6);

        for (let i = 0; i < positionAttribute.count; i++) {
          // Check if vertex is near the top (y=0.5) or bottom (y=-0.5) after translate
          const y = positionAttribute.getY(i);
          if (y > 0) {
            // Top face vertices
            colors.push(topColor.r, topColor.g, topColor.b);
          } else {
            // Bottom face vertices (and sides)
            colors.push(bottomColor.r, bottomColor.g, bottomColor.b);
          }
        }
        geometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );

        // Material using vertex colors
        const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                emissive: topColor,          // Set emissive color to the main bright color
                emissiveIntensity: 0.05       // Adjust intensity (0.0 to 1.0+) - Start lower
            });

        // Simple material for highlighting
        const highlightMaterial = new THREE.MeshLambertMaterial({
          color: app.config.highlightColor,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, 0, z); // Position base at y=0
        mesh.scale.y = totalHeight; // Scale height correctly
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Store data for interaction
        mesh.userData = {
          contribution: contribution,
          originalMaterial: material,
          highlightMaterial: highlightMaterial,
          originalHeight: totalHeight, // Store the calculated total height
        };

        app.scene.add(mesh);
        app.contributionMeshes.push(mesh);
      }

      // Create a month label
      // Create a month label
      function createMonthLabel(text, x, z) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");

        const scaleFactor = 2; // Increase resolution (e.g., 2x)
        const baseFontSize = 14;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 64 * scaleFactor; // Increased canvas width
        canvas.height = 32 * scaleFactor; // Increased canvas height

        context.fillStyle = "#c9d1d9"; // Use lighter text color

        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`; // Use increased font size and maybe bold

        context.textAlign = "center";
        context.textBaseline = "middle";

        // Ensure text antialiasing (usually default, but good to be aware of)
        context.imageSmoothingEnabled = true;
        // context.imageSmoothingQuality = "high"; // Optional: browser support varies

        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        // You can experiment with texture filtering if needed, but resolution is primary
        // texture.minFilter = THREE.LinearFilter; // Default
        // texture.magFilter = THREE.LinearFilter; // Default (prevents blockiness when scaling up)
        // texture.magFilter = THREE.NearestFilter; // Alternative: sharp pixels, can look blocky

        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
        }); // Slightly increased opacity maybe
        const sprite = new THREE.Sprite(material);

        sprite.position.set(x, 0.3, z); // Keep Y position slightly above ground

        // Adjust scale if needed to maintain visual size after increasing canvas resolution
        // Example: If canvas doubled (scaleFactor=2), maybe halve the original scale? Needs tuning.
        // Original scale was (4, 2, 1). Maybe try (2.5, 1.25, 1) or adjust as needed.
        sprite.scale.set(3, 1.5, 1); // Adjust these values

        app.scene.add(sprite);
        app.monthLabels.push(sprite);
      }

      // Create a day label
      // Create a day label
      function createDayLabel(text, x, z) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const scaleFactor = 2; // Increase resolution (e.g., 2x)
        const baseFontSize = 12;
        const fontSize = baseFontSize * scaleFactor;
        canvas.width = 48 * scaleFactor; // Increased canvas width
        canvas.height = 24 * scaleFactor; // Increased canvas height

        context.fillStyle = "#c9d1d9"; // Use lighter text color
        context.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif`; // Use increased font size and maybe bold
        context.textAlign = "center";
        context.textBaseline = "middle";
        // Ensure text antialiasing
        context.imageSmoothingEnabled = true;
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        // Optional: Experiment with filtering
        // texture.magFilter = THREE.LinearFilter; // Default - smoother but potentially blurrier
        // texture.magFilter = THREE.NearestFilter; // Sharper but potentially blocky

        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
        }); // Slightly increased opacity maybe
        const sprite = new THREE.Sprite(material);

        sprite.position.set(x, 0.3, z); // Keep Y position slightly above ground

        // Adjust scale if needed to maintain visual size
        // Original scale was (3, 1.5, 1). Maybe try (2, 1, 1) or adjust as needed.
        sprite.scale.set(2.5, 1.25, 1); // Adjust these values

        app.scene.add(sprite);
        app.weekLabels.push(sprite);
      }

      // Update heights of all cells based on height scale
      function updateHeights() {
        const baseHeight = 0.1;
        app.contributionMeshes.forEach((mesh) => {
          const { contribution } = mesh.userData;
          const scaledHeight =
            contribution.count * 0.1 * app.config.heightScale; // Use same scaling as creation
          const newTotalHeight = baseHeight + scaledHeight;

          // Update scale directly - vertex colors should interpolate with scale
          mesh.scale.y = newTotalHeight;
          // Store the new height if needed elsewhere, but userData.originalHeight should remain the initial one
          // mesh.userData.currentHeight = newTotalHeight;
        });
      }

      // Clear all scene elements for new data
      function clearScene() {
        // Remove contribution meshes
        while (app.contributionMeshes.length > 0) {
          const mesh = app.contributionMeshes.pop();
          if (mesh.parent) mesh.parent.remove(mesh); // Use parent.remove for cleaner removal
          mesh.geometry.dispose();
          // Dispose materials stored in userData
          if (mesh.userData.originalMaterial)
            mesh.userData.originalMaterial.dispose();
          if (mesh.userData.highlightMaterial)
            mesh.userData.highlightMaterial.dispose();
        }

        // Remove month labels
        while (app.monthLabels.length > 0) {
          const label = app.monthLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          label.material.dispose();
        }

        // Remove day labels
        while (app.weekLabels.length > 0) {
          const label = app.weekLabels.pop();
          if (label.parent) label.parent.remove(label);
          if (label.material.map) label.material.map.dispose();
          label.material.dispose();
        }

        // Remove any other objects like ground plane
        const objectsToRemove = [];
        app.scene.children.forEach((child) => {
          if (
            child instanceof THREE.Mesh &&
            child.geometry instanceof THREE.PlaneGeometry
          ) {
            objectsToRemove.push(child);
          }
          // Add other object types if necessary (e.g., helpers)
        });

        objectsToRemove.forEach((child) => {
          if (child.parent) child.parent.remove(child);
          child.geometry.dispose();
          child.material.dispose();
        });
        // Explicitly clear hover info
        document.getElementById("hover-info").textContent =
          "Hover over a cell to see details";
        if (app.hoveredCell) {
          app.hoveredCell = null; // Clear reference
        }
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Update controls if damping or auto-rotate is enabled
        app.controls.update();

        // Update TWEEN animations
        TWEEN.update();

        // Raycasting for hover effects
        app.raycaster.setFromCamera(app.mouse, app.camera);
        // Filter intersections to only include contribution meshes
        const intersects = app.raycaster.intersectObjects(
          app.contributionMeshes,
          false
        ); // non-recursive

        let intersectedObject = null;
        if (intersects.length > 0) {
          // Find the first mesh that has our userData structure
          for (let i = 0; i < intersects.length; i++) {
            if (
              intersects[i].object.userData &&
              intersects[i].object.userData.contribution
            ) {
              intersectedObject = intersects[i].object;
              break;
            }
          }
        }

        // Handle hover out
        if (app.hoveredCell && app.hoveredCell !== intersectedObject) {
          // Restore original material only if it exists
          if (
            app.hoveredCell.userData &&
            app.hoveredCell.userData.originalMaterial
          ) {
            app.hoveredCell.material =
              app.hoveredCell.userData.originalMaterial;
          }
          app.hoveredCell = null;
          document.getElementById("hover-info").textContent =
            "Hover over a cell to see details";
        }

        // Handle hover in
        if (intersectedObject && app.hoveredCell !== intersectedObject) {
          app.hoveredCell = intersectedObject;
          // Apply highlight material only if it exists
          if (
            app.hoveredCell.userData &&
            app.hoveredCell.userData.highlightMaterial
          ) {
            app.hoveredCell.material =
              app.hoveredCell.userData.highlightMaterial;
          }

          // Update info display
          const contribution = app.hoveredCell.userData.contribution;
          const date = new Date(contribution.date + "T00:00:00"); // Ensure correct date timezone handling
          const formattedDate = date.toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });

          document.getElementById("hover-info").innerHTML =
            `<strong>${formattedDate}</strong><br>` +
            `${contribution.count} contribution${
              contribution.count !== 1 ? "s" : ""
            }`;
        }

        if (app.composer) {
          app.composer.render();
        } else {
          // Fallback to direct rendering if composer isn't set up
          app.renderer.render(app.scene, app.camera);
        }
      }

      // == OrbitControls Implementation ==
      // Using a slightly modified version to ensure compatibility and avoid global conflicts
      THREE.OrbitControls = function (object, domElement) {
        this.object = object;

        this.domElement = domElement !== undefined ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.05;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = false; // if true, pan in screen-space
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = {
          LEFT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.DOLLY,
          RIGHT: THREE.MOUSE.PAN,
        };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {
          return spherical.phi;
        };

        this.getAzimuthalAngle = function () {
          return spherical.theta;
        };

        this.saveState = function () {
          scope.target0.copy(scope.target);
          scope.position0.copy(scope.object.position);
          scope.zoom0 = scope.object.zoom;
        };

        this.reset = function () {
          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;

          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);

          scope.update();

          state = STATE.NONE;
        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = (function () {
          var offset = new THREE.Vector3();

          // so camera.up is the orbit axis
          var quat = new THREE.Quaternion().setFromUnitVectors(
            object.up,
            new THREE.Vector3(0, 1, 0)
          );
          var quatInverse = quat.clone().invert();

          var lastPosition = new THREE.Vector3();
          var lastQuaternion = new THREE.Quaternion();

          return function update() {
            var position = scope.object.position;

            offset.copy(position).sub(scope.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis
            spherical.setFromVector3(offset);

            if (scope.autoRotate && state === STATE.NONE) {
              rotateLeft(getAutoRotationAngle());
            }

            if (scope.enableDamping) {
              spherical.theta += sphericalDelta.theta * scope.dampingFactor;
              spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
              spherical.theta += sphericalDelta.theta;
              spherical.phi += sphericalDelta.phi;
            }

            // restrict theta to be between desired limits
            spherical.theta = Math.max(
              scope.minAzimuthAngle,
              Math.min(scope.maxAzimuthAngle, spherical.theta)
            );

            // restrict phi to be between desired limits
            spherical.phi = Math.max(
              scope.minPolarAngle,
              Math.min(scope.maxPolarAngle, spherical.phi)
            );

            spherical.makeSafe();

            spherical.radius *= scale;

            // restrict radius to be between desired limits
            spherical.radius = Math.max(
              scope.minDistance,
              Math.min(scope.maxDistance, spherical.radius)
            );

            // move target to panned location

            if (scope.enableDamping === true) {
              scope.target.addScaledVector(panOffset, scope.dampingFactor);
            } else {
              scope.target.add(panOffset);
            }

            offset.setFromSpherical(spherical);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(scope.target).add(offset);

            scope.object.lookAt(scope.target);

            if (scope.enableDamping === true) {
              sphericalDelta.theta *= 1 - scope.dampingFactor;
              sphericalDelta.phi *= 1 - scope.dampingFactor;

              panOffset.multiplyScalar(1 - scope.dampingFactor);
            } else {
              sphericalDelta.set(0, 0, 0);

              panOffset.set(0, 0, 0);
            }

            scale = 1;

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (
              zoomChanged ||
              lastPosition.distanceToSquared(scope.object.position) > EPS ||
              8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
            ) {
              scope.dispatchEvent(changeEvent);

              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;

              return true;
            }

            return false;
          };
        })();

        this.dispose = function () {
          scope.domElement.removeEventListener(
            "contextmenu",
            onContextMenu,
            false
          );
          scope.domElement.removeEventListener("mousedown", onMouseDown, false);
          scope.domElement.removeEventListener("wheel", onMouseWheel, false);

          scope.domElement.removeEventListener(
            "touchstart",
            onTouchStart,
            false
          );
          scope.domElement.removeEventListener("touchend", onTouchEnd, false);
          scope.domElement.removeEventListener("touchmove", onTouchMove, false);

          document.removeEventListener("mousemove", onDocumentMouseMove, false); // Use correct name
          document.removeEventListener("mouseup", onDocumentMouseUp, false); // Use correct name

          scope.domElement.removeEventListener("keydown", onKeyDown, false);

          //scope.dispatchEvent( { type: 'dispose' } ); // should be added to code base according to https://github.com/mrdoob/three.js/pull/1517
        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: "change" };
        var startEvent = { type: "start" };
        var endEvent = { type: "end" };

        var STATE = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_DOLLY_PAN: 4,
        }; // Adjusted states slightly

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();

        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {
          return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
        }

        function getZoomScale() {
          return Math.pow(0.95, scope.zoomSpeed);
        }

        function rotateLeft(angle) {
          sphericalDelta.theta -= angle;
        }

        function rotateUp(angle) {
          sphericalDelta.phi -= angle;
        }

        var panLeft = (function () {
          var v = new THREE.Vector3();

          return function panLeft(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
            v.multiplyScalar(-distance);

            panOffset.add(v);
          };
        })();

        var panUp = (function () {
          var v = new THREE.Vector3();

          return function panUp(distance, objectMatrix) {
            if (scope.screenSpacePanning === true) {
              v.setFromMatrixColumn(objectMatrix, 1);
            } else {
              v.setFromMatrixColumn(objectMatrix, 0);
              v.crossVectors(scope.object.up, v);
            }

            v.multiplyScalar(distance);

            panOffset.add(v);
          };
        })();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = (function () {
          var offset = new THREE.Vector3();

          return function pan(deltaX, deltaY) {
            var element =
              scope.domElement === document
                ? scope.domElement.body
                : scope.domElement;

            if (scope.object.isPerspectiveCamera) {
              // perspective
              var position = scope.object.position;
              offset.copy(position).sub(scope.target);
              var targetDistance = offset.length();

              // half of the fov is center to top of screen
              targetDistance *= Math.tan(
                ((scope.object.fov / 2) * Math.PI) / 180.0
              );

              // we use only clientHeight here so aspect ratio does not distort speed
              panLeft(
                (2 * deltaX * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
              panUp(
                (2 * deltaY * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
            } else if (scope.object.isOrthographicCamera) {
              // orthographic
              panLeft(
                (deltaX * (scope.object.right - scope.object.left)) /
                  scope.object.zoom /
                  element.clientWidth,
                scope.object.matrix
              );
              panUp(
                (deltaY * (scope.object.top - scope.object.bottom)) /
                  scope.object.zoom /
                  element.clientHeight,
                scope.object.matrix
              );
            } else {
              // camera neither orthographic nor perspective
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
              );
              scope.enablePan = false;
            }
          };
        })();

        function dollyIn(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale /= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom * dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        function dollyOut(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale *= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom / dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate(event) {
          rotateStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownDolly(event) {
          dollyStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownPan(event) {
          panStart.set(event.clientX, event.clientY);
        }

        function handleMouseMoveRotate(event) {
          rotateEnd.set(event.clientX, event.clientY);

          rotateDelta
            .subVectors(rotateEnd, rotateStart)
            .multiplyScalar(scope.rotateSpeed);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height

          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleMouseMoveDolly(event) {
          dollyEnd.set(event.clientX, event.clientY);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {
            dollyIn(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyOut(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleMouseMovePan(event) {
          panEnd.set(event.clientX, event.clientY);

          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        // Renamed handler for document mouse up
        function onDocumentMouseUp(/*event*/) {
          if (scope.enabled === false) return;

          document.removeEventListener("mousemove", onDocumentMouseMove, false);
          document.removeEventListener("mouseup", onDocumentMouseUp, false);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        // Renamed handler for document mouse move
        function onDocumentMouseMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          if (state === STATE.ROTATE) {
            handleMouseMoveRotate(event);
          } else if (state === STATE.DOLLY) {
            handleMouseMoveDolly(event);
          } else if (state === STATE.PAN) {
            handleMouseMovePan(event);
          }
        }

        function onMouseDown(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          switch (event.button) {
            case scope.mouseButtons.LEFT:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (scope.enablePan === false) return;

                handleMouseDownPan(event);

                state = STATE.PAN;
              } else {
                if (scope.enableRotate === false) return;

                handleMouseDownRotate(event);

                state = STATE.ROTATE;
              }

              break;

            case scope.mouseButtons.MIDDLE:
              if (scope.enableZoom === false) return;

              handleMouseDownDolly(event);

              state = STATE.DOLLY;

              break;

            case scope.mouseButtons.RIGHT:
              if (scope.enablePan === false) return;

              handleMouseDownPan(event);

              state = STATE.PAN;

              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            // Add renamed listeners to document
            document.addEventListener("mousemove", onDocumentMouseMove, false);
            document.addEventListener("mouseup", onDocumentMouseUp, false);

            scope.dispatchEvent(startEvent);
          }
        }

        function onMouseWheel(event) {
          if (
            scope.enabled === false ||
            scope.enableZoom === false ||
            (state !== STATE.NONE && state !== STATE.ROTATE)
          )
            return;

          event.preventDefault();
          event.stopPropagation();

          scope.dispatchEvent(startEvent);

          handleMouseWheel(event);

          scope.dispatchEvent(endEvent);
        }

        function handleMouseWheel(event) {
          if (event.deltaY < 0) {
            dollyOut(getZoomScale());
          } else if (event.deltaY > 0) {
            dollyIn(getZoomScale());
          }

          scope.update();
        }

        function onKeyDown(event) {
          if (
            scope.enabled === false ||
            scope.enableKeys === false ||
            scope.enablePan === false
          )
            return;

          handleKeyDown(event);
        }

        function handleKeyDown(event) {
          var needsUpdate = false;

          switch (event.keyCode) {
            case scope.keys.UP:
              pan(0, scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.BOTTOM:
              pan(0, -scope.keyPanSpeed);
              needsUpdate = true;
              break;

            case scope.keys.LEFT:
              pan(scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;

            case scope.keys.RIGHT:
              pan(-scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;
          }

          if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            event.preventDefault();

            scope.update();
          }
        }

        function onTouchStart(event) {
          if (scope.enabled === false) return;

          event.preventDefault(); // Prevent scrolling.

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;

              handleTouchStartRotate(event);

              state = STATE.TOUCH_ROTATE;

              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false)
                return;

              handleTouchStartDollyPan(event);

              state = STATE.TOUCH_DOLLY_PAN;

              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            scope.dispatchEvent(startEvent);
          }
        }

        function handleTouchStartRotate(event) {
          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchStartDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;

            var distance = Math.sqrt(dx * dx + dy * dy);

            dollyStart.set(0, distance);
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

            panStart.set(x, y);
          }
        }

        function onTouchMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();
          event.stopPropagation();

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;
              if (state !== STATE.TOUCH_ROTATE) return; // is this needed?

              handleTouchMoveRotate(event);

              break;

            case 2: // two-fingered touch: dolly-pan
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              if (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?

              handleTouchMoveDollyPan(event);

              break;

            default:
              state = STATE.NONE;
          }
        }

        function handleTouchMoveRotate(event) {
          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);

          rotateDelta
            .subVectors(rotateEnd, rotateStart)
            .multiplyScalar(scope.rotateSpeed);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height

          rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleTouchMoveDollyPan(event) {
          if (scope.enableZoom) {
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;

            var distance = Math.sqrt(dx * dx + dy * dy);

            dollyEnd.set(0, distance);

            dollyDelta.set(
              0,
              Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed)
            );

            dollyIn(dollyDelta.y);

            dollyStart.copy(dollyEnd);
          }

          if (scope.enablePan) {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

            panEnd.set(x, y);

            panDelta
              .subVectors(panEnd, panStart)
              .multiplyScalar(scope.panSpeed);

            pan(panDelta.x, panDelta.y);

            panStart.copy(panEnd);
          }

          scope.update();
        }

        function onTouchEnd(/*event*/) {
          if (scope.enabled === false) return;

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        function onContextMenu(event) {
          if (scope.enabled === false) return;

          event.preventDefault();
        }

        // Add event listeners to the domElement
        scope.domElement.addEventListener("contextmenu", onContextMenu, false);

        scope.domElement.addEventListener("mousedown", onMouseDown, false);
        scope.domElement.addEventListener("wheel", onMouseWheel, false);

        scope.domElement.addEventListener("touchstart", onTouchStart, false);
        scope.domElement.addEventListener("touchend", onTouchEnd, false);
        scope.domElement.addEventListener("touchmove", onTouchMove, false);

        // Listen to window for keydown event
        window.addEventListener("keydown", onKeyDown, false); // Changed from scope.domElement

        // force an update at start
        this.update();
      };

      THREE.OrbitControls.prototype = Object.create(
        THREE.EventDispatcher.prototype
      );
      THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

      // Add event for Vector3 clamp
      // (This seems unnecessary as Vector3 already has clamp, min, max methods in r128)
      // THREE.Vector3.prototype.clamp = function(min, max) {
      //     this.x = Math.max(min.x, Math.min(max.x, this.x));
      //     this.y = Math.max(min.y, Math.min(max.y, this.y));
      //     this.z = Math.max(min.z, Math.min(max.z, this.z));
      //     return this;
      // };

      // Start application
      init();
      animate();
    </script>
  </body>
</html>
